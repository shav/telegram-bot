package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/shav/telegram-bot/internal/modules/finances/caches.cache -o ./mocks\cache.go -n CacheMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CacheMock implements finance_caches_spending_reports.cache
type CacheMock struct {
	t minimock.Tester

	funcDelete          func(ctx context.Context, keys ...string) (err error)
	inspectFuncDelete   func(ctx context.Context, keys ...string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mCacheMockDelete

	funcGetMap          func(ctx context.Context, key string) (value map[string]string, exists bool, err error)
	inspectFuncGetMap   func(ctx context.Context, key string)
	afterGetMapCounter  uint64
	beforeGetMapCounter uint64
	GetMapMock          mCacheMockGetMap

	funcSetMap          func(ctx context.Context, key string, value map[string]string, expireAt time.Time) (err error)
	inspectFuncSetMap   func(ctx context.Context, key string, value map[string]string, expireAt time.Time)
	afterSetMapCounter  uint64
	beforeSetMapCounter uint64
	SetMapMock          mCacheMockSetMap
}

// NewCacheMock returns a mock for finance_caches_spending_reports.cache
func NewCacheMock(t minimock.Tester) *CacheMock {
	m := &CacheMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteMock = mCacheMockDelete{mock: m}
	m.DeleteMock.callArgs = []*CacheMockDeleteParams{}

	m.GetMapMock = mCacheMockGetMap{mock: m}
	m.GetMapMock.callArgs = []*CacheMockGetMapParams{}

	m.SetMapMock = mCacheMockSetMap{mock: m}
	m.SetMapMock.callArgs = []*CacheMockSetMapParams{}

	return m
}

type mCacheMockDelete struct {
	mock               *CacheMock
	defaultExpectation *CacheMockDeleteExpectation
	expectations       []*CacheMockDeleteExpectation

	callArgs []*CacheMockDeleteParams
	mutex    sync.RWMutex
}

// CacheMockDeleteExpectation specifies expectation struct of the cache.Delete
type CacheMockDeleteExpectation struct {
	mock    *CacheMock
	params  *CacheMockDeleteParams
	results *CacheMockDeleteResults
	Counter uint64
}

// CacheMockDeleteParams contains parameters of the cache.Delete
type CacheMockDeleteParams struct {
	ctx  context.Context
	keys []string
}

// CacheMockDeleteResults contains results of the cache.Delete
type CacheMockDeleteResults struct {
	err error
}

// Expect sets up expected params for cache.Delete
func (mmDelete *mCacheMockDelete) Expect(ctx context.Context, keys ...string) *mCacheMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CacheMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CacheMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &CacheMockDeleteParams{ctx, keys}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the cache.Delete
func (mmDelete *mCacheMockDelete) Inspect(f func(ctx context.Context, keys ...string)) *mCacheMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for CacheMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by cache.Delete
func (mmDelete *mCacheMockDelete) Return(err error) *CacheMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CacheMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CacheMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &CacheMockDeleteResults{err}
	return mmDelete.mock
}

//Set uses given function f to mock the cache.Delete method
func (mmDelete *mCacheMockDelete) Set(f func(ctx context.Context, keys ...string) (err error)) *CacheMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the cache.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the cache.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the cache.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mCacheMockDelete) When(ctx context.Context, keys ...string) *CacheMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CacheMock.Delete mock is already set by Set")
	}

	expectation := &CacheMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &CacheMockDeleteParams{ctx, keys},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up cache.Delete return parameters for the expectation previously defined by the When method
func (e *CacheMockDeleteExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockDeleteResults{err}
	return e.mock
}

// Delete implements finance_caches_spending_reports.cache
func (mmDelete *CacheMock) Delete(ctx context.Context, keys ...string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, keys...)
	}

	mm_params := &CacheMockDeleteParams{ctx, keys}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := CacheMockDeleteParams{ctx, keys}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("CacheMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the CacheMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, keys...)
	}
	mmDelete.t.Fatalf("Unexpected call to CacheMock.Delete. %v %v", ctx, keys)
	return
}

// DeleteAfterCounter returns a count of finished CacheMock.Delete invocations
func (mmDelete *CacheMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of CacheMock.Delete invocations
func (mmDelete *CacheMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mCacheMockDelete) Calls() []*CacheMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*CacheMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *CacheMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.Delete")
		} else {
			m.t.Errorf("Expected call to CacheMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to CacheMock.Delete")
	}
}

type mCacheMockGetMap struct {
	mock               *CacheMock
	defaultExpectation *CacheMockGetMapExpectation
	expectations       []*CacheMockGetMapExpectation

	callArgs []*CacheMockGetMapParams
	mutex    sync.RWMutex
}

// CacheMockGetMapExpectation specifies expectation struct of the cache.GetMap
type CacheMockGetMapExpectation struct {
	mock    *CacheMock
	params  *CacheMockGetMapParams
	results *CacheMockGetMapResults
	Counter uint64
}

// CacheMockGetMapParams contains parameters of the cache.GetMap
type CacheMockGetMapParams struct {
	ctx context.Context
	key string
}

// CacheMockGetMapResults contains results of the cache.GetMap
type CacheMockGetMapResults struct {
	value  map[string]string
	exists bool
	err    error
}

// Expect sets up expected params for cache.GetMap
func (mmGetMap *mCacheMockGetMap) Expect(ctx context.Context, key string) *mCacheMockGetMap {
	if mmGetMap.mock.funcGetMap != nil {
		mmGetMap.mock.t.Fatalf("CacheMock.GetMap mock is already set by Set")
	}

	if mmGetMap.defaultExpectation == nil {
		mmGetMap.defaultExpectation = &CacheMockGetMapExpectation{}
	}

	mmGetMap.defaultExpectation.params = &CacheMockGetMapParams{ctx, key}
	for _, e := range mmGetMap.expectations {
		if minimock.Equal(e.params, mmGetMap.defaultExpectation.params) {
			mmGetMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMap.defaultExpectation.params)
		}
	}

	return mmGetMap
}

// Inspect accepts an inspector function that has same arguments as the cache.GetMap
func (mmGetMap *mCacheMockGetMap) Inspect(f func(ctx context.Context, key string)) *mCacheMockGetMap {
	if mmGetMap.mock.inspectFuncGetMap != nil {
		mmGetMap.mock.t.Fatalf("Inspect function is already set for CacheMock.GetMap")
	}

	mmGetMap.mock.inspectFuncGetMap = f

	return mmGetMap
}

// Return sets up results that will be returned by cache.GetMap
func (mmGetMap *mCacheMockGetMap) Return(value map[string]string, exists bool, err error) *CacheMock {
	if mmGetMap.mock.funcGetMap != nil {
		mmGetMap.mock.t.Fatalf("CacheMock.GetMap mock is already set by Set")
	}

	if mmGetMap.defaultExpectation == nil {
		mmGetMap.defaultExpectation = &CacheMockGetMapExpectation{mock: mmGetMap.mock}
	}
	mmGetMap.defaultExpectation.results = &CacheMockGetMapResults{value, exists, err}
	return mmGetMap.mock
}

//Set uses given function f to mock the cache.GetMap method
func (mmGetMap *mCacheMockGetMap) Set(f func(ctx context.Context, key string) (value map[string]string, exists bool, err error)) *CacheMock {
	if mmGetMap.defaultExpectation != nil {
		mmGetMap.mock.t.Fatalf("Default expectation is already set for the cache.GetMap method")
	}

	if len(mmGetMap.expectations) > 0 {
		mmGetMap.mock.t.Fatalf("Some expectations are already set for the cache.GetMap method")
	}

	mmGetMap.mock.funcGetMap = f
	return mmGetMap.mock
}

// When sets expectation for the cache.GetMap which will trigger the result defined by the following
// Then helper
func (mmGetMap *mCacheMockGetMap) When(ctx context.Context, key string) *CacheMockGetMapExpectation {
	if mmGetMap.mock.funcGetMap != nil {
		mmGetMap.mock.t.Fatalf("CacheMock.GetMap mock is already set by Set")
	}

	expectation := &CacheMockGetMapExpectation{
		mock:   mmGetMap.mock,
		params: &CacheMockGetMapParams{ctx, key},
	}
	mmGetMap.expectations = append(mmGetMap.expectations, expectation)
	return expectation
}

// Then sets up cache.GetMap return parameters for the expectation previously defined by the When method
func (e *CacheMockGetMapExpectation) Then(value map[string]string, exists bool, err error) *CacheMock {
	e.results = &CacheMockGetMapResults{value, exists, err}
	return e.mock
}

// GetMap implements finance_caches_spending_reports.cache
func (mmGetMap *CacheMock) GetMap(ctx context.Context, key string) (value map[string]string, exists bool, err error) {
	mm_atomic.AddUint64(&mmGetMap.beforeGetMapCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMap.afterGetMapCounter, 1)

	if mmGetMap.inspectFuncGetMap != nil {
		mmGetMap.inspectFuncGetMap(ctx, key)
	}

	mm_params := &CacheMockGetMapParams{ctx, key}

	// Record call args
	mmGetMap.GetMapMock.mutex.Lock()
	mmGetMap.GetMapMock.callArgs = append(mmGetMap.GetMapMock.callArgs, mm_params)
	mmGetMap.GetMapMock.mutex.Unlock()

	for _, e := range mmGetMap.GetMapMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.value, e.results.exists, e.results.err
		}
	}

	if mmGetMap.GetMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMap.GetMapMock.defaultExpectation.Counter, 1)
		mm_want := mmGetMap.GetMapMock.defaultExpectation.params
		mm_got := CacheMockGetMapParams{ctx, key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMap.t.Errorf("CacheMock.GetMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMap.GetMapMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMap.t.Fatal("No results are set for the CacheMock.GetMap")
		}
		return (*mm_results).value, (*mm_results).exists, (*mm_results).err
	}
	if mmGetMap.funcGetMap != nil {
		return mmGetMap.funcGetMap(ctx, key)
	}
	mmGetMap.t.Fatalf("Unexpected call to CacheMock.GetMap. %v %v", ctx, key)
	return
}

// GetMapAfterCounter returns a count of finished CacheMock.GetMap invocations
func (mmGetMap *CacheMock) GetMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMap.afterGetMapCounter)
}

// GetMapBeforeCounter returns a count of CacheMock.GetMap invocations
func (mmGetMap *CacheMock) GetMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMap.beforeGetMapCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.GetMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMap *mCacheMockGetMap) Calls() []*CacheMockGetMapParams {
	mmGetMap.mutex.RLock()

	argCopy := make([]*CacheMockGetMapParams, len(mmGetMap.callArgs))
	copy(argCopy, mmGetMap.callArgs)

	mmGetMap.mutex.RUnlock()

	return argCopy
}

// MinimockGetMapDone returns true if the count of the GetMap invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockGetMapDone() bool {
	for _, e := range m.GetMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMap != nil && mm_atomic.LoadUint64(&m.afterGetMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMapInspect logs each unmet expectation
func (m *CacheMock) MinimockGetMapInspect() {
	for _, e := range m.GetMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.GetMap with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMapCounter) < 1 {
		if m.GetMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.GetMap")
		} else {
			m.t.Errorf("Expected call to CacheMock.GetMap with params: %#v", *m.GetMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMap != nil && mm_atomic.LoadUint64(&m.afterGetMapCounter) < 1 {
		m.t.Error("Expected call to CacheMock.GetMap")
	}
}

type mCacheMockSetMap struct {
	mock               *CacheMock
	defaultExpectation *CacheMockSetMapExpectation
	expectations       []*CacheMockSetMapExpectation

	callArgs []*CacheMockSetMapParams
	mutex    sync.RWMutex
}

// CacheMockSetMapExpectation specifies expectation struct of the cache.SetMap
type CacheMockSetMapExpectation struct {
	mock    *CacheMock
	params  *CacheMockSetMapParams
	results *CacheMockSetMapResults
	Counter uint64
}

// CacheMockSetMapParams contains parameters of the cache.SetMap
type CacheMockSetMapParams struct {
	ctx      context.Context
	key      string
	value    map[string]string
	expireAt time.Time
}

// CacheMockSetMapResults contains results of the cache.SetMap
type CacheMockSetMapResults struct {
	err error
}

// Expect sets up expected params for cache.SetMap
func (mmSetMap *mCacheMockSetMap) Expect(ctx context.Context, key string, value map[string]string, expireAt time.Time) *mCacheMockSetMap {
	if mmSetMap.mock.funcSetMap != nil {
		mmSetMap.mock.t.Fatalf("CacheMock.SetMap mock is already set by Set")
	}

	if mmSetMap.defaultExpectation == nil {
		mmSetMap.defaultExpectation = &CacheMockSetMapExpectation{}
	}

	mmSetMap.defaultExpectation.params = &CacheMockSetMapParams{ctx, key, value, expireAt}
	for _, e := range mmSetMap.expectations {
		if minimock.Equal(e.params, mmSetMap.defaultExpectation.params) {
			mmSetMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetMap.defaultExpectation.params)
		}
	}

	return mmSetMap
}

// Inspect accepts an inspector function that has same arguments as the cache.SetMap
func (mmSetMap *mCacheMockSetMap) Inspect(f func(ctx context.Context, key string, value map[string]string, expireAt time.Time)) *mCacheMockSetMap {
	if mmSetMap.mock.inspectFuncSetMap != nil {
		mmSetMap.mock.t.Fatalf("Inspect function is already set for CacheMock.SetMap")
	}

	mmSetMap.mock.inspectFuncSetMap = f

	return mmSetMap
}

// Return sets up results that will be returned by cache.SetMap
func (mmSetMap *mCacheMockSetMap) Return(err error) *CacheMock {
	if mmSetMap.mock.funcSetMap != nil {
		mmSetMap.mock.t.Fatalf("CacheMock.SetMap mock is already set by Set")
	}

	if mmSetMap.defaultExpectation == nil {
		mmSetMap.defaultExpectation = &CacheMockSetMapExpectation{mock: mmSetMap.mock}
	}
	mmSetMap.defaultExpectation.results = &CacheMockSetMapResults{err}
	return mmSetMap.mock
}

//Set uses given function f to mock the cache.SetMap method
func (mmSetMap *mCacheMockSetMap) Set(f func(ctx context.Context, key string, value map[string]string, expireAt time.Time) (err error)) *CacheMock {
	if mmSetMap.defaultExpectation != nil {
		mmSetMap.mock.t.Fatalf("Default expectation is already set for the cache.SetMap method")
	}

	if len(mmSetMap.expectations) > 0 {
		mmSetMap.mock.t.Fatalf("Some expectations are already set for the cache.SetMap method")
	}

	mmSetMap.mock.funcSetMap = f
	return mmSetMap.mock
}

// When sets expectation for the cache.SetMap which will trigger the result defined by the following
// Then helper
func (mmSetMap *mCacheMockSetMap) When(ctx context.Context, key string, value map[string]string, expireAt time.Time) *CacheMockSetMapExpectation {
	if mmSetMap.mock.funcSetMap != nil {
		mmSetMap.mock.t.Fatalf("CacheMock.SetMap mock is already set by Set")
	}

	expectation := &CacheMockSetMapExpectation{
		mock:   mmSetMap.mock,
		params: &CacheMockSetMapParams{ctx, key, value, expireAt},
	}
	mmSetMap.expectations = append(mmSetMap.expectations, expectation)
	return expectation
}

// Then sets up cache.SetMap return parameters for the expectation previously defined by the When method
func (e *CacheMockSetMapExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockSetMapResults{err}
	return e.mock
}

// SetMap implements finance_caches_spending_reports.cache
func (mmSetMap *CacheMock) SetMap(ctx context.Context, key string, value map[string]string, expireAt time.Time) (err error) {
	mm_atomic.AddUint64(&mmSetMap.beforeSetMapCounter, 1)
	defer mm_atomic.AddUint64(&mmSetMap.afterSetMapCounter, 1)

	if mmSetMap.inspectFuncSetMap != nil {
		mmSetMap.inspectFuncSetMap(ctx, key, value, expireAt)
	}

	mm_params := &CacheMockSetMapParams{ctx, key, value, expireAt}

	// Record call args
	mmSetMap.SetMapMock.mutex.Lock()
	mmSetMap.SetMapMock.callArgs = append(mmSetMap.SetMapMock.callArgs, mm_params)
	mmSetMap.SetMapMock.mutex.Unlock()

	for _, e := range mmSetMap.SetMapMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetMap.SetMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetMap.SetMapMock.defaultExpectation.Counter, 1)
		mm_want := mmSetMap.SetMapMock.defaultExpectation.params
		mm_got := CacheMockSetMapParams{ctx, key, value, expireAt}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetMap.t.Errorf("CacheMock.SetMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetMap.SetMapMock.defaultExpectation.results
		if mm_results == nil {
			mmSetMap.t.Fatal("No results are set for the CacheMock.SetMap")
		}
		return (*mm_results).err
	}
	if mmSetMap.funcSetMap != nil {
		return mmSetMap.funcSetMap(ctx, key, value, expireAt)
	}
	mmSetMap.t.Fatalf("Unexpected call to CacheMock.SetMap. %v %v %v %v", ctx, key, value, expireAt)
	return
}

// SetMapAfterCounter returns a count of finished CacheMock.SetMap invocations
func (mmSetMap *CacheMock) SetMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetMap.afterSetMapCounter)
}

// SetMapBeforeCounter returns a count of CacheMock.SetMap invocations
func (mmSetMap *CacheMock) SetMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetMap.beforeSetMapCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.SetMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetMap *mCacheMockSetMap) Calls() []*CacheMockSetMapParams {
	mmSetMap.mutex.RLock()

	argCopy := make([]*CacheMockSetMapParams, len(mmSetMap.callArgs))
	copy(argCopy, mmSetMap.callArgs)

	mmSetMap.mutex.RUnlock()

	return argCopy
}

// MinimockSetMapDone returns true if the count of the SetMap invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockSetMapDone() bool {
	for _, e := range m.SetMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetMap != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetMapInspect logs each unmet expectation
func (m *CacheMock) MinimockSetMapInspect() {
	for _, e := range m.SetMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.SetMap with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		if m.SetMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.SetMap")
		} else {
			m.t.Errorf("Expected call to CacheMock.SetMap with params: %#v", *m.SetMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetMap != nil && mm_atomic.LoadUint64(&m.afterSetMapCounter) < 1 {
		m.t.Error("Expected call to CacheMock.SetMap")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CacheMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDeleteInspect()

		m.MinimockGetMapInspect()

		m.MinimockSetMapInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteDone() &&
		m.MinimockGetMapDone() &&
		m.MinimockSetMapDone()
}
