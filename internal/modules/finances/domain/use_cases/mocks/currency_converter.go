package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/shav/telegram-bot/internal/modules/finances/domain/use_cases.currencyConverter -o ./mocks\currency_converter.go -n CurrencyConverterMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/shopspring/decimal"
	finance_models "github.com/shav/telegram-bot/internal/modules/finances/domain/models"
)

// CurrencyConverterMock implements finances.currencyConverter
type CurrencyConverterMock struct {
	t minimock.Tester

	funcConvertSpendingsTableToUserCurrency          func(ctx context.Context, userId int64, spendingsTable finance_models.SpendingsByCategoryTable) (s1 finance_models.SpendingsByCategoryTable, err error)
	inspectFuncConvertSpendingsTableToUserCurrency   func(ctx context.Context, userId int64, spendingsTable finance_models.SpendingsByCategoryTable)
	afterConvertSpendingsTableToUserCurrencyCounter  uint64
	beforeConvertSpendingsTableToUserCurrencyCounter uint64
	ConvertSpendingsTableToUserCurrencyMock          mCurrencyConverterMockConvertSpendingsTableToUserCurrency

	funcConvertToDefaultCurrency          func(ctx context.Context, userId int64, amount decimal.Decimal) (d1 decimal.Decimal, err error)
	inspectFuncConvertToDefaultCurrency   func(ctx context.Context, userId int64, amount decimal.Decimal)
	afterConvertToDefaultCurrencyCounter  uint64
	beforeConvertToDefaultCurrencyCounter uint64
	ConvertToDefaultCurrencyMock          mCurrencyConverterMockConvertToDefaultCurrency

	funcConvertToUserCurrency          func(ctx context.Context, userId int64, defaultAmount decimal.Decimal) (d1 decimal.Decimal, err error)
	inspectFuncConvertToUserCurrency   func(ctx context.Context, userId int64, defaultAmount decimal.Decimal)
	afterConvertToUserCurrencyCounter  uint64
	beforeConvertToUserCurrencyCounter uint64
	ConvertToUserCurrencyMock          mCurrencyConverterMockConvertToUserCurrency
}

// NewCurrencyConverterMock returns a mock for finances.currencyConverter
func NewCurrencyConverterMock(t minimock.Tester) *CurrencyConverterMock {
	m := &CurrencyConverterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConvertSpendingsTableToUserCurrencyMock = mCurrencyConverterMockConvertSpendingsTableToUserCurrency{mock: m}
	m.ConvertSpendingsTableToUserCurrencyMock.callArgs = []*CurrencyConverterMockConvertSpendingsTableToUserCurrencyParams{}

	m.ConvertToDefaultCurrencyMock = mCurrencyConverterMockConvertToDefaultCurrency{mock: m}
	m.ConvertToDefaultCurrencyMock.callArgs = []*CurrencyConverterMockConvertToDefaultCurrencyParams{}

	m.ConvertToUserCurrencyMock = mCurrencyConverterMockConvertToUserCurrency{mock: m}
	m.ConvertToUserCurrencyMock.callArgs = []*CurrencyConverterMockConvertToUserCurrencyParams{}

	return m
}

type mCurrencyConverterMockConvertSpendingsTableToUserCurrency struct {
	mock               *CurrencyConverterMock
	defaultExpectation *CurrencyConverterMockConvertSpendingsTableToUserCurrencyExpectation
	expectations       []*CurrencyConverterMockConvertSpendingsTableToUserCurrencyExpectation

	callArgs []*CurrencyConverterMockConvertSpendingsTableToUserCurrencyParams
	mutex    sync.RWMutex
}

// CurrencyConverterMockConvertSpendingsTableToUserCurrencyExpectation specifies expectation struct of the currencyConverter.ConvertSpendingsTableToUserCurrency
type CurrencyConverterMockConvertSpendingsTableToUserCurrencyExpectation struct {
	mock    *CurrencyConverterMock
	params  *CurrencyConverterMockConvertSpendingsTableToUserCurrencyParams
	results *CurrencyConverterMockConvertSpendingsTableToUserCurrencyResults
	Counter uint64
}

// CurrencyConverterMockConvertSpendingsTableToUserCurrencyParams contains parameters of the currencyConverter.ConvertSpendingsTableToUserCurrency
type CurrencyConverterMockConvertSpendingsTableToUserCurrencyParams struct {
	ctx            context.Context
	userId         int64
	spendingsTable finance_models.SpendingsByCategoryTable
}

// CurrencyConverterMockConvertSpendingsTableToUserCurrencyResults contains results of the currencyConverter.ConvertSpendingsTableToUserCurrency
type CurrencyConverterMockConvertSpendingsTableToUserCurrencyResults struct {
	s1  finance_models.SpendingsByCategoryTable
	err error
}

// Expect sets up expected params for currencyConverter.ConvertSpendingsTableToUserCurrency
func (mmConvertSpendingsTableToUserCurrency *mCurrencyConverterMockConvertSpendingsTableToUserCurrency) Expect(ctx context.Context, userId int64, spendingsTable finance_models.SpendingsByCategoryTable) *mCurrencyConverterMockConvertSpendingsTableToUserCurrency {
	if mmConvertSpendingsTableToUserCurrency.mock.funcConvertSpendingsTableToUserCurrency != nil {
		mmConvertSpendingsTableToUserCurrency.mock.t.Fatalf("CurrencyConverterMock.ConvertSpendingsTableToUserCurrency mock is already set by Set")
	}

	if mmConvertSpendingsTableToUserCurrency.defaultExpectation == nil {
		mmConvertSpendingsTableToUserCurrency.defaultExpectation = &CurrencyConverterMockConvertSpendingsTableToUserCurrencyExpectation{}
	}

	mmConvertSpendingsTableToUserCurrency.defaultExpectation.params = &CurrencyConverterMockConvertSpendingsTableToUserCurrencyParams{ctx, userId, spendingsTable}
	for _, e := range mmConvertSpendingsTableToUserCurrency.expectations {
		if minimock.Equal(e.params, mmConvertSpendingsTableToUserCurrency.defaultExpectation.params) {
			mmConvertSpendingsTableToUserCurrency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertSpendingsTableToUserCurrency.defaultExpectation.params)
		}
	}

	return mmConvertSpendingsTableToUserCurrency
}

// Inspect accepts an inspector function that has same arguments as the currencyConverter.ConvertSpendingsTableToUserCurrency
func (mmConvertSpendingsTableToUserCurrency *mCurrencyConverterMockConvertSpendingsTableToUserCurrency) Inspect(f func(ctx context.Context, userId int64, spendingsTable finance_models.SpendingsByCategoryTable)) *mCurrencyConverterMockConvertSpendingsTableToUserCurrency {
	if mmConvertSpendingsTableToUserCurrency.mock.inspectFuncConvertSpendingsTableToUserCurrency != nil {
		mmConvertSpendingsTableToUserCurrency.mock.t.Fatalf("Inspect function is already set for CurrencyConverterMock.ConvertSpendingsTableToUserCurrency")
	}

	mmConvertSpendingsTableToUserCurrency.mock.inspectFuncConvertSpendingsTableToUserCurrency = f

	return mmConvertSpendingsTableToUserCurrency
}

// Return sets up results that will be returned by currencyConverter.ConvertSpendingsTableToUserCurrency
func (mmConvertSpendingsTableToUserCurrency *mCurrencyConverterMockConvertSpendingsTableToUserCurrency) Return(s1 finance_models.SpendingsByCategoryTable, err error) *CurrencyConverterMock {
	if mmConvertSpendingsTableToUserCurrency.mock.funcConvertSpendingsTableToUserCurrency != nil {
		mmConvertSpendingsTableToUserCurrency.mock.t.Fatalf("CurrencyConverterMock.ConvertSpendingsTableToUserCurrency mock is already set by Set")
	}

	if mmConvertSpendingsTableToUserCurrency.defaultExpectation == nil {
		mmConvertSpendingsTableToUserCurrency.defaultExpectation = &CurrencyConverterMockConvertSpendingsTableToUserCurrencyExpectation{mock: mmConvertSpendingsTableToUserCurrency.mock}
	}
	mmConvertSpendingsTableToUserCurrency.defaultExpectation.results = &CurrencyConverterMockConvertSpendingsTableToUserCurrencyResults{s1, err}
	return mmConvertSpendingsTableToUserCurrency.mock
}

//Set uses given function f to mock the currencyConverter.ConvertSpendingsTableToUserCurrency method
func (mmConvertSpendingsTableToUserCurrency *mCurrencyConverterMockConvertSpendingsTableToUserCurrency) Set(f func(ctx context.Context, userId int64, spendingsTable finance_models.SpendingsByCategoryTable) (s1 finance_models.SpendingsByCategoryTable, err error)) *CurrencyConverterMock {
	if mmConvertSpendingsTableToUserCurrency.defaultExpectation != nil {
		mmConvertSpendingsTableToUserCurrency.mock.t.Fatalf("Default expectation is already set for the currencyConverter.ConvertSpendingsTableToUserCurrency method")
	}

	if len(mmConvertSpendingsTableToUserCurrency.expectations) > 0 {
		mmConvertSpendingsTableToUserCurrency.mock.t.Fatalf("Some expectations are already set for the currencyConverter.ConvertSpendingsTableToUserCurrency method")
	}

	mmConvertSpendingsTableToUserCurrency.mock.funcConvertSpendingsTableToUserCurrency = f
	return mmConvertSpendingsTableToUserCurrency.mock
}

// When sets expectation for the currencyConverter.ConvertSpendingsTableToUserCurrency which will trigger the result defined by the following
// Then helper
func (mmConvertSpendingsTableToUserCurrency *mCurrencyConverterMockConvertSpendingsTableToUserCurrency) When(ctx context.Context, userId int64, spendingsTable finance_models.SpendingsByCategoryTable) *CurrencyConverterMockConvertSpendingsTableToUserCurrencyExpectation {
	if mmConvertSpendingsTableToUserCurrency.mock.funcConvertSpendingsTableToUserCurrency != nil {
		mmConvertSpendingsTableToUserCurrency.mock.t.Fatalf("CurrencyConverterMock.ConvertSpendingsTableToUserCurrency mock is already set by Set")
	}

	expectation := &CurrencyConverterMockConvertSpendingsTableToUserCurrencyExpectation{
		mock:   mmConvertSpendingsTableToUserCurrency.mock,
		params: &CurrencyConverterMockConvertSpendingsTableToUserCurrencyParams{ctx, userId, spendingsTable},
	}
	mmConvertSpendingsTableToUserCurrency.expectations = append(mmConvertSpendingsTableToUserCurrency.expectations, expectation)
	return expectation
}

// Then sets up currencyConverter.ConvertSpendingsTableToUserCurrency return parameters for the expectation previously defined by the When method
func (e *CurrencyConverterMockConvertSpendingsTableToUserCurrencyExpectation) Then(s1 finance_models.SpendingsByCategoryTable, err error) *CurrencyConverterMock {
	e.results = &CurrencyConverterMockConvertSpendingsTableToUserCurrencyResults{s1, err}
	return e.mock
}

// ConvertSpendingsTableToUserCurrency implements finances.currencyConverter
func (mmConvertSpendingsTableToUserCurrency *CurrencyConverterMock) ConvertSpendingsTableToUserCurrency(ctx context.Context, userId int64, spendingsTable finance_models.SpendingsByCategoryTable) (s1 finance_models.SpendingsByCategoryTable, err error) {
	mm_atomic.AddUint64(&mmConvertSpendingsTableToUserCurrency.beforeConvertSpendingsTableToUserCurrencyCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertSpendingsTableToUserCurrency.afterConvertSpendingsTableToUserCurrencyCounter, 1)

	if mmConvertSpendingsTableToUserCurrency.inspectFuncConvertSpendingsTableToUserCurrency != nil {
		mmConvertSpendingsTableToUserCurrency.inspectFuncConvertSpendingsTableToUserCurrency(ctx, userId, spendingsTable)
	}

	mm_params := &CurrencyConverterMockConvertSpendingsTableToUserCurrencyParams{ctx, userId, spendingsTable}

	// Record call args
	mmConvertSpendingsTableToUserCurrency.ConvertSpendingsTableToUserCurrencyMock.mutex.Lock()
	mmConvertSpendingsTableToUserCurrency.ConvertSpendingsTableToUserCurrencyMock.callArgs = append(mmConvertSpendingsTableToUserCurrency.ConvertSpendingsTableToUserCurrencyMock.callArgs, mm_params)
	mmConvertSpendingsTableToUserCurrency.ConvertSpendingsTableToUserCurrencyMock.mutex.Unlock()

	for _, e := range mmConvertSpendingsTableToUserCurrency.ConvertSpendingsTableToUserCurrencyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmConvertSpendingsTableToUserCurrency.ConvertSpendingsTableToUserCurrencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertSpendingsTableToUserCurrency.ConvertSpendingsTableToUserCurrencyMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertSpendingsTableToUserCurrency.ConvertSpendingsTableToUserCurrencyMock.defaultExpectation.params
		mm_got := CurrencyConverterMockConvertSpendingsTableToUserCurrencyParams{ctx, userId, spendingsTable}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertSpendingsTableToUserCurrency.t.Errorf("CurrencyConverterMock.ConvertSpendingsTableToUserCurrency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertSpendingsTableToUserCurrency.ConvertSpendingsTableToUserCurrencyMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertSpendingsTableToUserCurrency.t.Fatal("No results are set for the CurrencyConverterMock.ConvertSpendingsTableToUserCurrency")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmConvertSpendingsTableToUserCurrency.funcConvertSpendingsTableToUserCurrency != nil {
		return mmConvertSpendingsTableToUserCurrency.funcConvertSpendingsTableToUserCurrency(ctx, userId, spendingsTable)
	}
	mmConvertSpendingsTableToUserCurrency.t.Fatalf("Unexpected call to CurrencyConverterMock.ConvertSpendingsTableToUserCurrency. %v %v %v", ctx, userId, spendingsTable)
	return
}

// ConvertSpendingsTableToUserCurrencyAfterCounter returns a count of finished CurrencyConverterMock.ConvertSpendingsTableToUserCurrency invocations
func (mmConvertSpendingsTableToUserCurrency *CurrencyConverterMock) ConvertSpendingsTableToUserCurrencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSpendingsTableToUserCurrency.afterConvertSpendingsTableToUserCurrencyCounter)
}

// ConvertSpendingsTableToUserCurrencyBeforeCounter returns a count of CurrencyConverterMock.ConvertSpendingsTableToUserCurrency invocations
func (mmConvertSpendingsTableToUserCurrency *CurrencyConverterMock) ConvertSpendingsTableToUserCurrencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSpendingsTableToUserCurrency.beforeConvertSpendingsTableToUserCurrencyCounter)
}

// Calls returns a list of arguments used in each call to CurrencyConverterMock.ConvertSpendingsTableToUserCurrency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertSpendingsTableToUserCurrency *mCurrencyConverterMockConvertSpendingsTableToUserCurrency) Calls() []*CurrencyConverterMockConvertSpendingsTableToUserCurrencyParams {
	mmConvertSpendingsTableToUserCurrency.mutex.RLock()

	argCopy := make([]*CurrencyConverterMockConvertSpendingsTableToUserCurrencyParams, len(mmConvertSpendingsTableToUserCurrency.callArgs))
	copy(argCopy, mmConvertSpendingsTableToUserCurrency.callArgs)

	mmConvertSpendingsTableToUserCurrency.mutex.RUnlock()

	return argCopy
}

// MinimockConvertSpendingsTableToUserCurrencyDone returns true if the count of the ConvertSpendingsTableToUserCurrency invocations corresponds
// the number of defined expectations
func (m *CurrencyConverterMock) MinimockConvertSpendingsTableToUserCurrencyDone() bool {
	for _, e := range m.ConvertSpendingsTableToUserCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertSpendingsTableToUserCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConvertSpendingsTableToUserCurrencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertSpendingsTableToUserCurrency != nil && mm_atomic.LoadUint64(&m.afterConvertSpendingsTableToUserCurrencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockConvertSpendingsTableToUserCurrencyInspect logs each unmet expectation
func (m *CurrencyConverterMock) MinimockConvertSpendingsTableToUserCurrencyInspect() {
	for _, e := range m.ConvertSpendingsTableToUserCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CurrencyConverterMock.ConvertSpendingsTableToUserCurrency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertSpendingsTableToUserCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConvertSpendingsTableToUserCurrencyCounter) < 1 {
		if m.ConvertSpendingsTableToUserCurrencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CurrencyConverterMock.ConvertSpendingsTableToUserCurrency")
		} else {
			m.t.Errorf("Expected call to CurrencyConverterMock.ConvertSpendingsTableToUserCurrency with params: %#v", *m.ConvertSpendingsTableToUserCurrencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertSpendingsTableToUserCurrency != nil && mm_atomic.LoadUint64(&m.afterConvertSpendingsTableToUserCurrencyCounter) < 1 {
		m.t.Error("Expected call to CurrencyConverterMock.ConvertSpendingsTableToUserCurrency")
	}
}

type mCurrencyConverterMockConvertToDefaultCurrency struct {
	mock               *CurrencyConverterMock
	defaultExpectation *CurrencyConverterMockConvertToDefaultCurrencyExpectation
	expectations       []*CurrencyConverterMockConvertToDefaultCurrencyExpectation

	callArgs []*CurrencyConverterMockConvertToDefaultCurrencyParams
	mutex    sync.RWMutex
}

// CurrencyConverterMockConvertToDefaultCurrencyExpectation specifies expectation struct of the currencyConverter.ConvertToDefaultCurrency
type CurrencyConverterMockConvertToDefaultCurrencyExpectation struct {
	mock    *CurrencyConverterMock
	params  *CurrencyConverterMockConvertToDefaultCurrencyParams
	results *CurrencyConverterMockConvertToDefaultCurrencyResults
	Counter uint64
}

// CurrencyConverterMockConvertToDefaultCurrencyParams contains parameters of the currencyConverter.ConvertToDefaultCurrency
type CurrencyConverterMockConvertToDefaultCurrencyParams struct {
	ctx    context.Context
	userId int64
	amount decimal.Decimal
}

// CurrencyConverterMockConvertToDefaultCurrencyResults contains results of the currencyConverter.ConvertToDefaultCurrency
type CurrencyConverterMockConvertToDefaultCurrencyResults struct {
	d1  decimal.Decimal
	err error
}

// Expect sets up expected params for currencyConverter.ConvertToDefaultCurrency
func (mmConvertToDefaultCurrency *mCurrencyConverterMockConvertToDefaultCurrency) Expect(ctx context.Context, userId int64, amount decimal.Decimal) *mCurrencyConverterMockConvertToDefaultCurrency {
	if mmConvertToDefaultCurrency.mock.funcConvertToDefaultCurrency != nil {
		mmConvertToDefaultCurrency.mock.t.Fatalf("CurrencyConverterMock.ConvertToDefaultCurrency mock is already set by Set")
	}

	if mmConvertToDefaultCurrency.defaultExpectation == nil {
		mmConvertToDefaultCurrency.defaultExpectation = &CurrencyConverterMockConvertToDefaultCurrencyExpectation{}
	}

	mmConvertToDefaultCurrency.defaultExpectation.params = &CurrencyConverterMockConvertToDefaultCurrencyParams{ctx, userId, amount}
	for _, e := range mmConvertToDefaultCurrency.expectations {
		if minimock.Equal(e.params, mmConvertToDefaultCurrency.defaultExpectation.params) {
			mmConvertToDefaultCurrency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertToDefaultCurrency.defaultExpectation.params)
		}
	}

	return mmConvertToDefaultCurrency
}

// Inspect accepts an inspector function that has same arguments as the currencyConverter.ConvertToDefaultCurrency
func (mmConvertToDefaultCurrency *mCurrencyConverterMockConvertToDefaultCurrency) Inspect(f func(ctx context.Context, userId int64, amount decimal.Decimal)) *mCurrencyConverterMockConvertToDefaultCurrency {
	if mmConvertToDefaultCurrency.mock.inspectFuncConvertToDefaultCurrency != nil {
		mmConvertToDefaultCurrency.mock.t.Fatalf("Inspect function is already set for CurrencyConverterMock.ConvertToDefaultCurrency")
	}

	mmConvertToDefaultCurrency.mock.inspectFuncConvertToDefaultCurrency = f

	return mmConvertToDefaultCurrency
}

// Return sets up results that will be returned by currencyConverter.ConvertToDefaultCurrency
func (mmConvertToDefaultCurrency *mCurrencyConverterMockConvertToDefaultCurrency) Return(d1 decimal.Decimal, err error) *CurrencyConverterMock {
	if mmConvertToDefaultCurrency.mock.funcConvertToDefaultCurrency != nil {
		mmConvertToDefaultCurrency.mock.t.Fatalf("CurrencyConverterMock.ConvertToDefaultCurrency mock is already set by Set")
	}

	if mmConvertToDefaultCurrency.defaultExpectation == nil {
		mmConvertToDefaultCurrency.defaultExpectation = &CurrencyConverterMockConvertToDefaultCurrencyExpectation{mock: mmConvertToDefaultCurrency.mock}
	}
	mmConvertToDefaultCurrency.defaultExpectation.results = &CurrencyConverterMockConvertToDefaultCurrencyResults{d1, err}
	return mmConvertToDefaultCurrency.mock
}

//Set uses given function f to mock the currencyConverter.ConvertToDefaultCurrency method
func (mmConvertToDefaultCurrency *mCurrencyConverterMockConvertToDefaultCurrency) Set(f func(ctx context.Context, userId int64, amount decimal.Decimal) (d1 decimal.Decimal, err error)) *CurrencyConverterMock {
	if mmConvertToDefaultCurrency.defaultExpectation != nil {
		mmConvertToDefaultCurrency.mock.t.Fatalf("Default expectation is already set for the currencyConverter.ConvertToDefaultCurrency method")
	}

	if len(mmConvertToDefaultCurrency.expectations) > 0 {
		mmConvertToDefaultCurrency.mock.t.Fatalf("Some expectations are already set for the currencyConverter.ConvertToDefaultCurrency method")
	}

	mmConvertToDefaultCurrency.mock.funcConvertToDefaultCurrency = f
	return mmConvertToDefaultCurrency.mock
}

// When sets expectation for the currencyConverter.ConvertToDefaultCurrency which will trigger the result defined by the following
// Then helper
func (mmConvertToDefaultCurrency *mCurrencyConverterMockConvertToDefaultCurrency) When(ctx context.Context, userId int64, amount decimal.Decimal) *CurrencyConverterMockConvertToDefaultCurrencyExpectation {
	if mmConvertToDefaultCurrency.mock.funcConvertToDefaultCurrency != nil {
		mmConvertToDefaultCurrency.mock.t.Fatalf("CurrencyConverterMock.ConvertToDefaultCurrency mock is already set by Set")
	}

	expectation := &CurrencyConverterMockConvertToDefaultCurrencyExpectation{
		mock:   mmConvertToDefaultCurrency.mock,
		params: &CurrencyConverterMockConvertToDefaultCurrencyParams{ctx, userId, amount},
	}
	mmConvertToDefaultCurrency.expectations = append(mmConvertToDefaultCurrency.expectations, expectation)
	return expectation
}

// Then sets up currencyConverter.ConvertToDefaultCurrency return parameters for the expectation previously defined by the When method
func (e *CurrencyConverterMockConvertToDefaultCurrencyExpectation) Then(d1 decimal.Decimal, err error) *CurrencyConverterMock {
	e.results = &CurrencyConverterMockConvertToDefaultCurrencyResults{d1, err}
	return e.mock
}

// ConvertToDefaultCurrency implements finances.currencyConverter
func (mmConvertToDefaultCurrency *CurrencyConverterMock) ConvertToDefaultCurrency(ctx context.Context, userId int64, amount decimal.Decimal) (d1 decimal.Decimal, err error) {
	mm_atomic.AddUint64(&mmConvertToDefaultCurrency.beforeConvertToDefaultCurrencyCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertToDefaultCurrency.afterConvertToDefaultCurrencyCounter, 1)

	if mmConvertToDefaultCurrency.inspectFuncConvertToDefaultCurrency != nil {
		mmConvertToDefaultCurrency.inspectFuncConvertToDefaultCurrency(ctx, userId, amount)
	}

	mm_params := &CurrencyConverterMockConvertToDefaultCurrencyParams{ctx, userId, amount}

	// Record call args
	mmConvertToDefaultCurrency.ConvertToDefaultCurrencyMock.mutex.Lock()
	mmConvertToDefaultCurrency.ConvertToDefaultCurrencyMock.callArgs = append(mmConvertToDefaultCurrency.ConvertToDefaultCurrencyMock.callArgs, mm_params)
	mmConvertToDefaultCurrency.ConvertToDefaultCurrencyMock.mutex.Unlock()

	for _, e := range mmConvertToDefaultCurrency.ConvertToDefaultCurrencyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.err
		}
	}

	if mmConvertToDefaultCurrency.ConvertToDefaultCurrencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertToDefaultCurrency.ConvertToDefaultCurrencyMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertToDefaultCurrency.ConvertToDefaultCurrencyMock.defaultExpectation.params
		mm_got := CurrencyConverterMockConvertToDefaultCurrencyParams{ctx, userId, amount}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertToDefaultCurrency.t.Errorf("CurrencyConverterMock.ConvertToDefaultCurrency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertToDefaultCurrency.ConvertToDefaultCurrencyMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertToDefaultCurrency.t.Fatal("No results are set for the CurrencyConverterMock.ConvertToDefaultCurrency")
		}
		return (*mm_results).d1, (*mm_results).err
	}
	if mmConvertToDefaultCurrency.funcConvertToDefaultCurrency != nil {
		return mmConvertToDefaultCurrency.funcConvertToDefaultCurrency(ctx, userId, amount)
	}
	mmConvertToDefaultCurrency.t.Fatalf("Unexpected call to CurrencyConverterMock.ConvertToDefaultCurrency. %v %v %v", ctx, userId, amount)
	return
}

// ConvertToDefaultCurrencyAfterCounter returns a count of finished CurrencyConverterMock.ConvertToDefaultCurrency invocations
func (mmConvertToDefaultCurrency *CurrencyConverterMock) ConvertToDefaultCurrencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToDefaultCurrency.afterConvertToDefaultCurrencyCounter)
}

// ConvertToDefaultCurrencyBeforeCounter returns a count of CurrencyConverterMock.ConvertToDefaultCurrency invocations
func (mmConvertToDefaultCurrency *CurrencyConverterMock) ConvertToDefaultCurrencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToDefaultCurrency.beforeConvertToDefaultCurrencyCounter)
}

// Calls returns a list of arguments used in each call to CurrencyConverterMock.ConvertToDefaultCurrency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertToDefaultCurrency *mCurrencyConverterMockConvertToDefaultCurrency) Calls() []*CurrencyConverterMockConvertToDefaultCurrencyParams {
	mmConvertToDefaultCurrency.mutex.RLock()

	argCopy := make([]*CurrencyConverterMockConvertToDefaultCurrencyParams, len(mmConvertToDefaultCurrency.callArgs))
	copy(argCopy, mmConvertToDefaultCurrency.callArgs)

	mmConvertToDefaultCurrency.mutex.RUnlock()

	return argCopy
}

// MinimockConvertToDefaultCurrencyDone returns true if the count of the ConvertToDefaultCurrency invocations corresponds
// the number of defined expectations
func (m *CurrencyConverterMock) MinimockConvertToDefaultCurrencyDone() bool {
	for _, e := range m.ConvertToDefaultCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertToDefaultCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConvertToDefaultCurrencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertToDefaultCurrency != nil && mm_atomic.LoadUint64(&m.afterConvertToDefaultCurrencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockConvertToDefaultCurrencyInspect logs each unmet expectation
func (m *CurrencyConverterMock) MinimockConvertToDefaultCurrencyInspect() {
	for _, e := range m.ConvertToDefaultCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CurrencyConverterMock.ConvertToDefaultCurrency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertToDefaultCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConvertToDefaultCurrencyCounter) < 1 {
		if m.ConvertToDefaultCurrencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CurrencyConverterMock.ConvertToDefaultCurrency")
		} else {
			m.t.Errorf("Expected call to CurrencyConverterMock.ConvertToDefaultCurrency with params: %#v", *m.ConvertToDefaultCurrencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertToDefaultCurrency != nil && mm_atomic.LoadUint64(&m.afterConvertToDefaultCurrencyCounter) < 1 {
		m.t.Error("Expected call to CurrencyConverterMock.ConvertToDefaultCurrency")
	}
}

type mCurrencyConverterMockConvertToUserCurrency struct {
	mock               *CurrencyConverterMock
	defaultExpectation *CurrencyConverterMockConvertToUserCurrencyExpectation
	expectations       []*CurrencyConverterMockConvertToUserCurrencyExpectation

	callArgs []*CurrencyConverterMockConvertToUserCurrencyParams
	mutex    sync.RWMutex
}

// CurrencyConverterMockConvertToUserCurrencyExpectation specifies expectation struct of the currencyConverter.ConvertToUserCurrency
type CurrencyConverterMockConvertToUserCurrencyExpectation struct {
	mock    *CurrencyConverterMock
	params  *CurrencyConverterMockConvertToUserCurrencyParams
	results *CurrencyConverterMockConvertToUserCurrencyResults
	Counter uint64
}

// CurrencyConverterMockConvertToUserCurrencyParams contains parameters of the currencyConverter.ConvertToUserCurrency
type CurrencyConverterMockConvertToUserCurrencyParams struct {
	ctx           context.Context
	userId        int64
	defaultAmount decimal.Decimal
}

// CurrencyConverterMockConvertToUserCurrencyResults contains results of the currencyConverter.ConvertToUserCurrency
type CurrencyConverterMockConvertToUserCurrencyResults struct {
	d1  decimal.Decimal
	err error
}

// Expect sets up expected params for currencyConverter.ConvertToUserCurrency
func (mmConvertToUserCurrency *mCurrencyConverterMockConvertToUserCurrency) Expect(ctx context.Context, userId int64, defaultAmount decimal.Decimal) *mCurrencyConverterMockConvertToUserCurrency {
	if mmConvertToUserCurrency.mock.funcConvertToUserCurrency != nil {
		mmConvertToUserCurrency.mock.t.Fatalf("CurrencyConverterMock.ConvertToUserCurrency mock is already set by Set")
	}

	if mmConvertToUserCurrency.defaultExpectation == nil {
		mmConvertToUserCurrency.defaultExpectation = &CurrencyConverterMockConvertToUserCurrencyExpectation{}
	}

	mmConvertToUserCurrency.defaultExpectation.params = &CurrencyConverterMockConvertToUserCurrencyParams{ctx, userId, defaultAmount}
	for _, e := range mmConvertToUserCurrency.expectations {
		if minimock.Equal(e.params, mmConvertToUserCurrency.defaultExpectation.params) {
			mmConvertToUserCurrency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertToUserCurrency.defaultExpectation.params)
		}
	}

	return mmConvertToUserCurrency
}

// Inspect accepts an inspector function that has same arguments as the currencyConverter.ConvertToUserCurrency
func (mmConvertToUserCurrency *mCurrencyConverterMockConvertToUserCurrency) Inspect(f func(ctx context.Context, userId int64, defaultAmount decimal.Decimal)) *mCurrencyConverterMockConvertToUserCurrency {
	if mmConvertToUserCurrency.mock.inspectFuncConvertToUserCurrency != nil {
		mmConvertToUserCurrency.mock.t.Fatalf("Inspect function is already set for CurrencyConverterMock.ConvertToUserCurrency")
	}

	mmConvertToUserCurrency.mock.inspectFuncConvertToUserCurrency = f

	return mmConvertToUserCurrency
}

// Return sets up results that will be returned by currencyConverter.ConvertToUserCurrency
func (mmConvertToUserCurrency *mCurrencyConverterMockConvertToUserCurrency) Return(d1 decimal.Decimal, err error) *CurrencyConverterMock {
	if mmConvertToUserCurrency.mock.funcConvertToUserCurrency != nil {
		mmConvertToUserCurrency.mock.t.Fatalf("CurrencyConverterMock.ConvertToUserCurrency mock is already set by Set")
	}

	if mmConvertToUserCurrency.defaultExpectation == nil {
		mmConvertToUserCurrency.defaultExpectation = &CurrencyConverterMockConvertToUserCurrencyExpectation{mock: mmConvertToUserCurrency.mock}
	}
	mmConvertToUserCurrency.defaultExpectation.results = &CurrencyConverterMockConvertToUserCurrencyResults{d1, err}
	return mmConvertToUserCurrency.mock
}

//Set uses given function f to mock the currencyConverter.ConvertToUserCurrency method
func (mmConvertToUserCurrency *mCurrencyConverterMockConvertToUserCurrency) Set(f func(ctx context.Context, userId int64, defaultAmount decimal.Decimal) (d1 decimal.Decimal, err error)) *CurrencyConverterMock {
	if mmConvertToUserCurrency.defaultExpectation != nil {
		mmConvertToUserCurrency.mock.t.Fatalf("Default expectation is already set for the currencyConverter.ConvertToUserCurrency method")
	}

	if len(mmConvertToUserCurrency.expectations) > 0 {
		mmConvertToUserCurrency.mock.t.Fatalf("Some expectations are already set for the currencyConverter.ConvertToUserCurrency method")
	}

	mmConvertToUserCurrency.mock.funcConvertToUserCurrency = f
	return mmConvertToUserCurrency.mock
}

// When sets expectation for the currencyConverter.ConvertToUserCurrency which will trigger the result defined by the following
// Then helper
func (mmConvertToUserCurrency *mCurrencyConverterMockConvertToUserCurrency) When(ctx context.Context, userId int64, defaultAmount decimal.Decimal) *CurrencyConverterMockConvertToUserCurrencyExpectation {
	if mmConvertToUserCurrency.mock.funcConvertToUserCurrency != nil {
		mmConvertToUserCurrency.mock.t.Fatalf("CurrencyConverterMock.ConvertToUserCurrency mock is already set by Set")
	}

	expectation := &CurrencyConverterMockConvertToUserCurrencyExpectation{
		mock:   mmConvertToUserCurrency.mock,
		params: &CurrencyConverterMockConvertToUserCurrencyParams{ctx, userId, defaultAmount},
	}
	mmConvertToUserCurrency.expectations = append(mmConvertToUserCurrency.expectations, expectation)
	return expectation
}

// Then sets up currencyConverter.ConvertToUserCurrency return parameters for the expectation previously defined by the When method
func (e *CurrencyConverterMockConvertToUserCurrencyExpectation) Then(d1 decimal.Decimal, err error) *CurrencyConverterMock {
	e.results = &CurrencyConverterMockConvertToUserCurrencyResults{d1, err}
	return e.mock
}

// ConvertToUserCurrency implements finances.currencyConverter
func (mmConvertToUserCurrency *CurrencyConverterMock) ConvertToUserCurrency(ctx context.Context, userId int64, defaultAmount decimal.Decimal) (d1 decimal.Decimal, err error) {
	mm_atomic.AddUint64(&mmConvertToUserCurrency.beforeConvertToUserCurrencyCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertToUserCurrency.afterConvertToUserCurrencyCounter, 1)

	if mmConvertToUserCurrency.inspectFuncConvertToUserCurrency != nil {
		mmConvertToUserCurrency.inspectFuncConvertToUserCurrency(ctx, userId, defaultAmount)
	}

	mm_params := &CurrencyConverterMockConvertToUserCurrencyParams{ctx, userId, defaultAmount}

	// Record call args
	mmConvertToUserCurrency.ConvertToUserCurrencyMock.mutex.Lock()
	mmConvertToUserCurrency.ConvertToUserCurrencyMock.callArgs = append(mmConvertToUserCurrency.ConvertToUserCurrencyMock.callArgs, mm_params)
	mmConvertToUserCurrency.ConvertToUserCurrencyMock.mutex.Unlock()

	for _, e := range mmConvertToUserCurrency.ConvertToUserCurrencyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.err
		}
	}

	if mmConvertToUserCurrency.ConvertToUserCurrencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertToUserCurrency.ConvertToUserCurrencyMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertToUserCurrency.ConvertToUserCurrencyMock.defaultExpectation.params
		mm_got := CurrencyConverterMockConvertToUserCurrencyParams{ctx, userId, defaultAmount}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertToUserCurrency.t.Errorf("CurrencyConverterMock.ConvertToUserCurrency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertToUserCurrency.ConvertToUserCurrencyMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertToUserCurrency.t.Fatal("No results are set for the CurrencyConverterMock.ConvertToUserCurrency")
		}
		return (*mm_results).d1, (*mm_results).err
	}
	if mmConvertToUserCurrency.funcConvertToUserCurrency != nil {
		return mmConvertToUserCurrency.funcConvertToUserCurrency(ctx, userId, defaultAmount)
	}
	mmConvertToUserCurrency.t.Fatalf("Unexpected call to CurrencyConverterMock.ConvertToUserCurrency. %v %v %v", ctx, userId, defaultAmount)
	return
}

// ConvertToUserCurrencyAfterCounter returns a count of finished CurrencyConverterMock.ConvertToUserCurrency invocations
func (mmConvertToUserCurrency *CurrencyConverterMock) ConvertToUserCurrencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToUserCurrency.afterConvertToUserCurrencyCounter)
}

// ConvertToUserCurrencyBeforeCounter returns a count of CurrencyConverterMock.ConvertToUserCurrency invocations
func (mmConvertToUserCurrency *CurrencyConverterMock) ConvertToUserCurrencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToUserCurrency.beforeConvertToUserCurrencyCounter)
}

// Calls returns a list of arguments used in each call to CurrencyConverterMock.ConvertToUserCurrency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertToUserCurrency *mCurrencyConverterMockConvertToUserCurrency) Calls() []*CurrencyConverterMockConvertToUserCurrencyParams {
	mmConvertToUserCurrency.mutex.RLock()

	argCopy := make([]*CurrencyConverterMockConvertToUserCurrencyParams, len(mmConvertToUserCurrency.callArgs))
	copy(argCopy, mmConvertToUserCurrency.callArgs)

	mmConvertToUserCurrency.mutex.RUnlock()

	return argCopy
}

// MinimockConvertToUserCurrencyDone returns true if the count of the ConvertToUserCurrency invocations corresponds
// the number of defined expectations
func (m *CurrencyConverterMock) MinimockConvertToUserCurrencyDone() bool {
	for _, e := range m.ConvertToUserCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertToUserCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConvertToUserCurrencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertToUserCurrency != nil && mm_atomic.LoadUint64(&m.afterConvertToUserCurrencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockConvertToUserCurrencyInspect logs each unmet expectation
func (m *CurrencyConverterMock) MinimockConvertToUserCurrencyInspect() {
	for _, e := range m.ConvertToUserCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CurrencyConverterMock.ConvertToUserCurrency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertToUserCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConvertToUserCurrencyCounter) < 1 {
		if m.ConvertToUserCurrencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CurrencyConverterMock.ConvertToUserCurrency")
		} else {
			m.t.Errorf("Expected call to CurrencyConverterMock.ConvertToUserCurrency with params: %#v", *m.ConvertToUserCurrencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertToUserCurrency != nil && mm_atomic.LoadUint64(&m.afterConvertToUserCurrencyCounter) < 1 {
		m.t.Error("Expected call to CurrencyConverterMock.ConvertToUserCurrency")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CurrencyConverterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockConvertSpendingsTableToUserCurrencyInspect()

		m.MinimockConvertToDefaultCurrencyInspect()

		m.MinimockConvertToUserCurrencyInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CurrencyConverterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CurrencyConverterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConvertSpendingsTableToUserCurrencyDone() &&
		m.MinimockConvertToDefaultCurrencyDone() &&
		m.MinimockConvertToUserCurrencyDone()
}
