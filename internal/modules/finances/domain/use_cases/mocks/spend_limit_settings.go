package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/shav/telegram-bot/internal/modules/finances/domain/use_cases.spendLimitSettings -o ./mocks\spend_limit_settings.go -n SpendLimitSettingsMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/shopspring/decimal"
	"github.com/shav/telegram-bot/internal/common/date"
	tr "github.com/shav/telegram-bot/internal/common/transactions"
)

// SpendLimitSettingsMock implements fin_use_cases.spendLimitSettings
type SpendLimitSettingsMock struct {
	t minimock.Tester

	funcGetSpendLimit          func(ctx context.Context, ts tr.Transaction, userId int64, period date.Month) (limit decimal.Decimal, exists bool, err error)
	inspectFuncGetSpendLimit   func(ctx context.Context, ts tr.Transaction, userId int64, period date.Month)
	afterGetSpendLimitCounter  uint64
	beforeGetSpendLimitCounter uint64
	GetSpendLimitMock          mSpendLimitSettingsMockGetSpendLimit

	funcSetSpendLimit          func(ctx context.Context, ts tr.Transaction, userId int64, limit decimal.Decimal, period date.Month) (err error)
	inspectFuncSetSpendLimit   func(ctx context.Context, ts tr.Transaction, userId int64, limit decimal.Decimal, period date.Month)
	afterSetSpendLimitCounter  uint64
	beforeSetSpendLimitCounter uint64
	SetSpendLimitMock          mSpendLimitSettingsMockSetSpendLimit
}

// NewSpendLimitSettingsMock returns a mock for fin_use_cases.spendLimitSettings
func NewSpendLimitSettingsMock(t minimock.Tester) *SpendLimitSettingsMock {
	m := &SpendLimitSettingsMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetSpendLimitMock = mSpendLimitSettingsMockGetSpendLimit{mock: m}
	m.GetSpendLimitMock.callArgs = []*SpendLimitSettingsMockGetSpendLimitParams{}

	m.SetSpendLimitMock = mSpendLimitSettingsMockSetSpendLimit{mock: m}
	m.SetSpendLimitMock.callArgs = []*SpendLimitSettingsMockSetSpendLimitParams{}

	return m
}

type mSpendLimitSettingsMockGetSpendLimit struct {
	mock               *SpendLimitSettingsMock
	defaultExpectation *SpendLimitSettingsMockGetSpendLimitExpectation
	expectations       []*SpendLimitSettingsMockGetSpendLimitExpectation

	callArgs []*SpendLimitSettingsMockGetSpendLimitParams
	mutex    sync.RWMutex
}

// SpendLimitSettingsMockGetSpendLimitExpectation specifies expectation struct of the spendLimitSettings.GetSpendLimit
type SpendLimitSettingsMockGetSpendLimitExpectation struct {
	mock    *SpendLimitSettingsMock
	params  *SpendLimitSettingsMockGetSpendLimitParams
	results *SpendLimitSettingsMockGetSpendLimitResults
	Counter uint64
}

// SpendLimitSettingsMockGetSpendLimitParams contains parameters of the spendLimitSettings.GetSpendLimit
type SpendLimitSettingsMockGetSpendLimitParams struct {
	ctx    context.Context
	ts     tr.Transaction
	userId int64
	period date.Month
}

// SpendLimitSettingsMockGetSpendLimitResults contains results of the spendLimitSettings.GetSpendLimit
type SpendLimitSettingsMockGetSpendLimitResults struct {
	limit  decimal.Decimal
	exists bool
	err    error
}

// Expect sets up expected params for spendLimitSettings.GetSpendLimit
func (mmGetSpendLimit *mSpendLimitSettingsMockGetSpendLimit) Expect(ctx context.Context, ts tr.Transaction, userId int64, period date.Month) *mSpendLimitSettingsMockGetSpendLimit {
	if mmGetSpendLimit.mock.funcGetSpendLimit != nil {
		mmGetSpendLimit.mock.t.Fatalf("SpendLimitSettingsMock.GetSpendLimit mock is already set by Set")
	}

	if mmGetSpendLimit.defaultExpectation == nil {
		mmGetSpendLimit.defaultExpectation = &SpendLimitSettingsMockGetSpendLimitExpectation{}
	}

	mmGetSpendLimit.defaultExpectation.params = &SpendLimitSettingsMockGetSpendLimitParams{ctx, ts, userId, period}
	for _, e := range mmGetSpendLimit.expectations {
		if minimock.Equal(e.params, mmGetSpendLimit.defaultExpectation.params) {
			mmGetSpendLimit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSpendLimit.defaultExpectation.params)
		}
	}

	return mmGetSpendLimit
}

// Inspect accepts an inspector function that has same arguments as the spendLimitSettings.GetSpendLimit
func (mmGetSpendLimit *mSpendLimitSettingsMockGetSpendLimit) Inspect(f func(ctx context.Context, ts tr.Transaction, userId int64, period date.Month)) *mSpendLimitSettingsMockGetSpendLimit {
	if mmGetSpendLimit.mock.inspectFuncGetSpendLimit != nil {
		mmGetSpendLimit.mock.t.Fatalf("Inspect function is already set for SpendLimitSettingsMock.GetSpendLimit")
	}

	mmGetSpendLimit.mock.inspectFuncGetSpendLimit = f

	return mmGetSpendLimit
}

// Return sets up results that will be returned by spendLimitSettings.GetSpendLimit
func (mmGetSpendLimit *mSpendLimitSettingsMockGetSpendLimit) Return(limit decimal.Decimal, exists bool, err error) *SpendLimitSettingsMock {
	if mmGetSpendLimit.mock.funcGetSpendLimit != nil {
		mmGetSpendLimit.mock.t.Fatalf("SpendLimitSettingsMock.GetSpendLimit mock is already set by Set")
	}

	if mmGetSpendLimit.defaultExpectation == nil {
		mmGetSpendLimit.defaultExpectation = &SpendLimitSettingsMockGetSpendLimitExpectation{mock: mmGetSpendLimit.mock}
	}
	mmGetSpendLimit.defaultExpectation.results = &SpendLimitSettingsMockGetSpendLimitResults{limit, exists, err}
	return mmGetSpendLimit.mock
}

//Set uses given function f to mock the spendLimitSettings.GetSpendLimit method
func (mmGetSpendLimit *mSpendLimitSettingsMockGetSpendLimit) Set(f func(ctx context.Context, ts tr.Transaction, userId int64, period date.Month) (limit decimal.Decimal, exists bool, err error)) *SpendLimitSettingsMock {
	if mmGetSpendLimit.defaultExpectation != nil {
		mmGetSpendLimit.mock.t.Fatalf("Default expectation is already set for the spendLimitSettings.GetSpendLimit method")
	}

	if len(mmGetSpendLimit.expectations) > 0 {
		mmGetSpendLimit.mock.t.Fatalf("Some expectations are already set for the spendLimitSettings.GetSpendLimit method")
	}

	mmGetSpendLimit.mock.funcGetSpendLimit = f
	return mmGetSpendLimit.mock
}

// When sets expectation for the spendLimitSettings.GetSpendLimit which will trigger the result defined by the following
// Then helper
func (mmGetSpendLimit *mSpendLimitSettingsMockGetSpendLimit) When(ctx context.Context, ts tr.Transaction, userId int64, period date.Month) *SpendLimitSettingsMockGetSpendLimitExpectation {
	if mmGetSpendLimit.mock.funcGetSpendLimit != nil {
		mmGetSpendLimit.mock.t.Fatalf("SpendLimitSettingsMock.GetSpendLimit mock is already set by Set")
	}

	expectation := &SpendLimitSettingsMockGetSpendLimitExpectation{
		mock:   mmGetSpendLimit.mock,
		params: &SpendLimitSettingsMockGetSpendLimitParams{ctx, ts, userId, period},
	}
	mmGetSpendLimit.expectations = append(mmGetSpendLimit.expectations, expectation)
	return expectation
}

// Then sets up spendLimitSettings.GetSpendLimit return parameters for the expectation previously defined by the When method
func (e *SpendLimitSettingsMockGetSpendLimitExpectation) Then(limit decimal.Decimal, exists bool, err error) *SpendLimitSettingsMock {
	e.results = &SpendLimitSettingsMockGetSpendLimitResults{limit, exists, err}
	return e.mock
}

// GetSpendLimit implements fin_use_cases.spendLimitSettings
func (mmGetSpendLimit *SpendLimitSettingsMock) GetSpendLimit(ctx context.Context, ts tr.Transaction, userId int64, period date.Month) (limit decimal.Decimal, exists bool, err error) {
	mm_atomic.AddUint64(&mmGetSpendLimit.beforeGetSpendLimitCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSpendLimit.afterGetSpendLimitCounter, 1)

	if mmGetSpendLimit.inspectFuncGetSpendLimit != nil {
		mmGetSpendLimit.inspectFuncGetSpendLimit(ctx, ts, userId, period)
	}

	mm_params := &SpendLimitSettingsMockGetSpendLimitParams{ctx, ts, userId, period}

	// Record call args
	mmGetSpendLimit.GetSpendLimitMock.mutex.Lock()
	mmGetSpendLimit.GetSpendLimitMock.callArgs = append(mmGetSpendLimit.GetSpendLimitMock.callArgs, mm_params)
	mmGetSpendLimit.GetSpendLimitMock.mutex.Unlock()

	for _, e := range mmGetSpendLimit.GetSpendLimitMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.limit, e.results.exists, e.results.err
		}
	}

	if mmGetSpendLimit.GetSpendLimitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSpendLimit.GetSpendLimitMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSpendLimit.GetSpendLimitMock.defaultExpectation.params
		mm_got := SpendLimitSettingsMockGetSpendLimitParams{ctx, ts, userId, period}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSpendLimit.t.Errorf("SpendLimitSettingsMock.GetSpendLimit got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSpendLimit.GetSpendLimitMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSpendLimit.t.Fatal("No results are set for the SpendLimitSettingsMock.GetSpendLimit")
		}
		return (*mm_results).limit, (*mm_results).exists, (*mm_results).err
	}
	if mmGetSpendLimit.funcGetSpendLimit != nil {
		return mmGetSpendLimit.funcGetSpendLimit(ctx, ts, userId, period)
	}
	mmGetSpendLimit.t.Fatalf("Unexpected call to SpendLimitSettingsMock.GetSpendLimit. %v %v %v %v", ctx, ts, userId, period)
	return
}

// GetSpendLimitAfterCounter returns a count of finished SpendLimitSettingsMock.GetSpendLimit invocations
func (mmGetSpendLimit *SpendLimitSettingsMock) GetSpendLimitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSpendLimit.afterGetSpendLimitCounter)
}

// GetSpendLimitBeforeCounter returns a count of SpendLimitSettingsMock.GetSpendLimit invocations
func (mmGetSpendLimit *SpendLimitSettingsMock) GetSpendLimitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSpendLimit.beforeGetSpendLimitCounter)
}

// Calls returns a list of arguments used in each call to SpendLimitSettingsMock.GetSpendLimit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSpendLimit *mSpendLimitSettingsMockGetSpendLimit) Calls() []*SpendLimitSettingsMockGetSpendLimitParams {
	mmGetSpendLimit.mutex.RLock()

	argCopy := make([]*SpendLimitSettingsMockGetSpendLimitParams, len(mmGetSpendLimit.callArgs))
	copy(argCopy, mmGetSpendLimit.callArgs)

	mmGetSpendLimit.mutex.RUnlock()

	return argCopy
}

// MinimockGetSpendLimitDone returns true if the count of the GetSpendLimit invocations corresponds
// the number of defined expectations
func (m *SpendLimitSettingsMock) MinimockGetSpendLimitDone() bool {
	for _, e := range m.GetSpendLimitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSpendLimitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSpendLimitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSpendLimit != nil && mm_atomic.LoadUint64(&m.afterGetSpendLimitCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSpendLimitInspect logs each unmet expectation
func (m *SpendLimitSettingsMock) MinimockGetSpendLimitInspect() {
	for _, e := range m.GetSpendLimitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpendLimitSettingsMock.GetSpendLimit with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSpendLimitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSpendLimitCounter) < 1 {
		if m.GetSpendLimitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpendLimitSettingsMock.GetSpendLimit")
		} else {
			m.t.Errorf("Expected call to SpendLimitSettingsMock.GetSpendLimit with params: %#v", *m.GetSpendLimitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSpendLimit != nil && mm_atomic.LoadUint64(&m.afterGetSpendLimitCounter) < 1 {
		m.t.Error("Expected call to SpendLimitSettingsMock.GetSpendLimit")
	}
}

type mSpendLimitSettingsMockSetSpendLimit struct {
	mock               *SpendLimitSettingsMock
	defaultExpectation *SpendLimitSettingsMockSetSpendLimitExpectation
	expectations       []*SpendLimitSettingsMockSetSpendLimitExpectation

	callArgs []*SpendLimitSettingsMockSetSpendLimitParams
	mutex    sync.RWMutex
}

// SpendLimitSettingsMockSetSpendLimitExpectation specifies expectation struct of the spendLimitSettings.SetSpendLimit
type SpendLimitSettingsMockSetSpendLimitExpectation struct {
	mock    *SpendLimitSettingsMock
	params  *SpendLimitSettingsMockSetSpendLimitParams
	results *SpendLimitSettingsMockSetSpendLimitResults
	Counter uint64
}

// SpendLimitSettingsMockSetSpendLimitParams contains parameters of the spendLimitSettings.SetSpendLimit
type SpendLimitSettingsMockSetSpendLimitParams struct {
	ctx    context.Context
	ts     tr.Transaction
	userId int64
	limit  decimal.Decimal
	period date.Month
}

// SpendLimitSettingsMockSetSpendLimitResults contains results of the spendLimitSettings.SetSpendLimit
type SpendLimitSettingsMockSetSpendLimitResults struct {
	err error
}

// Expect sets up expected params for spendLimitSettings.SetSpendLimit
func (mmSetSpendLimit *mSpendLimitSettingsMockSetSpendLimit) Expect(ctx context.Context, ts tr.Transaction, userId int64, limit decimal.Decimal, period date.Month) *mSpendLimitSettingsMockSetSpendLimit {
	if mmSetSpendLimit.mock.funcSetSpendLimit != nil {
		mmSetSpendLimit.mock.t.Fatalf("SpendLimitSettingsMock.SetSpendLimit mock is already set by Set")
	}

	if mmSetSpendLimit.defaultExpectation == nil {
		mmSetSpendLimit.defaultExpectation = &SpendLimitSettingsMockSetSpendLimitExpectation{}
	}

	mmSetSpendLimit.defaultExpectation.params = &SpendLimitSettingsMockSetSpendLimitParams{ctx, ts, userId, limit, period}
	for _, e := range mmSetSpendLimit.expectations {
		if minimock.Equal(e.params, mmSetSpendLimit.defaultExpectation.params) {
			mmSetSpendLimit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetSpendLimit.defaultExpectation.params)
		}
	}

	return mmSetSpendLimit
}

// Inspect accepts an inspector function that has same arguments as the spendLimitSettings.SetSpendLimit
func (mmSetSpendLimit *mSpendLimitSettingsMockSetSpendLimit) Inspect(f func(ctx context.Context, ts tr.Transaction, userId int64, limit decimal.Decimal, period date.Month)) *mSpendLimitSettingsMockSetSpendLimit {
	if mmSetSpendLimit.mock.inspectFuncSetSpendLimit != nil {
		mmSetSpendLimit.mock.t.Fatalf("Inspect function is already set for SpendLimitSettingsMock.SetSpendLimit")
	}

	mmSetSpendLimit.mock.inspectFuncSetSpendLimit = f

	return mmSetSpendLimit
}

// Return sets up results that will be returned by spendLimitSettings.SetSpendLimit
func (mmSetSpendLimit *mSpendLimitSettingsMockSetSpendLimit) Return(err error) *SpendLimitSettingsMock {
	if mmSetSpendLimit.mock.funcSetSpendLimit != nil {
		mmSetSpendLimit.mock.t.Fatalf("SpendLimitSettingsMock.SetSpendLimit mock is already set by Set")
	}

	if mmSetSpendLimit.defaultExpectation == nil {
		mmSetSpendLimit.defaultExpectation = &SpendLimitSettingsMockSetSpendLimitExpectation{mock: mmSetSpendLimit.mock}
	}
	mmSetSpendLimit.defaultExpectation.results = &SpendLimitSettingsMockSetSpendLimitResults{err}
	return mmSetSpendLimit.mock
}

//Set uses given function f to mock the spendLimitSettings.SetSpendLimit method
func (mmSetSpendLimit *mSpendLimitSettingsMockSetSpendLimit) Set(f func(ctx context.Context, ts tr.Transaction, userId int64, limit decimal.Decimal, period date.Month) (err error)) *SpendLimitSettingsMock {
	if mmSetSpendLimit.defaultExpectation != nil {
		mmSetSpendLimit.mock.t.Fatalf("Default expectation is already set for the spendLimitSettings.SetSpendLimit method")
	}

	if len(mmSetSpendLimit.expectations) > 0 {
		mmSetSpendLimit.mock.t.Fatalf("Some expectations are already set for the spendLimitSettings.SetSpendLimit method")
	}

	mmSetSpendLimit.mock.funcSetSpendLimit = f
	return mmSetSpendLimit.mock
}

// When sets expectation for the spendLimitSettings.SetSpendLimit which will trigger the result defined by the following
// Then helper
func (mmSetSpendLimit *mSpendLimitSettingsMockSetSpendLimit) When(ctx context.Context, ts tr.Transaction, userId int64, limit decimal.Decimal, period date.Month) *SpendLimitSettingsMockSetSpendLimitExpectation {
	if mmSetSpendLimit.mock.funcSetSpendLimit != nil {
		mmSetSpendLimit.mock.t.Fatalf("SpendLimitSettingsMock.SetSpendLimit mock is already set by Set")
	}

	expectation := &SpendLimitSettingsMockSetSpendLimitExpectation{
		mock:   mmSetSpendLimit.mock,
		params: &SpendLimitSettingsMockSetSpendLimitParams{ctx, ts, userId, limit, period},
	}
	mmSetSpendLimit.expectations = append(mmSetSpendLimit.expectations, expectation)
	return expectation
}

// Then sets up spendLimitSettings.SetSpendLimit return parameters for the expectation previously defined by the When method
func (e *SpendLimitSettingsMockSetSpendLimitExpectation) Then(err error) *SpendLimitSettingsMock {
	e.results = &SpendLimitSettingsMockSetSpendLimitResults{err}
	return e.mock
}

// SetSpendLimit implements fin_use_cases.spendLimitSettings
func (mmSetSpendLimit *SpendLimitSettingsMock) SetSpendLimit(ctx context.Context, ts tr.Transaction, userId int64, limit decimal.Decimal, period date.Month) (err error) {
	mm_atomic.AddUint64(&mmSetSpendLimit.beforeSetSpendLimitCounter, 1)
	defer mm_atomic.AddUint64(&mmSetSpendLimit.afterSetSpendLimitCounter, 1)

	if mmSetSpendLimit.inspectFuncSetSpendLimit != nil {
		mmSetSpendLimit.inspectFuncSetSpendLimit(ctx, ts, userId, limit, period)
	}

	mm_params := &SpendLimitSettingsMockSetSpendLimitParams{ctx, ts, userId, limit, period}

	// Record call args
	mmSetSpendLimit.SetSpendLimitMock.mutex.Lock()
	mmSetSpendLimit.SetSpendLimitMock.callArgs = append(mmSetSpendLimit.SetSpendLimitMock.callArgs, mm_params)
	mmSetSpendLimit.SetSpendLimitMock.mutex.Unlock()

	for _, e := range mmSetSpendLimit.SetSpendLimitMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetSpendLimit.SetSpendLimitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetSpendLimit.SetSpendLimitMock.defaultExpectation.Counter, 1)
		mm_want := mmSetSpendLimit.SetSpendLimitMock.defaultExpectation.params
		mm_got := SpendLimitSettingsMockSetSpendLimitParams{ctx, ts, userId, limit, period}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetSpendLimit.t.Errorf("SpendLimitSettingsMock.SetSpendLimit got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetSpendLimit.SetSpendLimitMock.defaultExpectation.results
		if mm_results == nil {
			mmSetSpendLimit.t.Fatal("No results are set for the SpendLimitSettingsMock.SetSpendLimit")
		}
		return (*mm_results).err
	}
	if mmSetSpendLimit.funcSetSpendLimit != nil {
		return mmSetSpendLimit.funcSetSpendLimit(ctx, ts, userId, limit, period)
	}
	mmSetSpendLimit.t.Fatalf("Unexpected call to SpendLimitSettingsMock.SetSpendLimit. %v %v %v %v %v", ctx, ts, userId, limit, period)
	return
}

// SetSpendLimitAfterCounter returns a count of finished SpendLimitSettingsMock.SetSpendLimit invocations
func (mmSetSpendLimit *SpendLimitSettingsMock) SetSpendLimitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetSpendLimit.afterSetSpendLimitCounter)
}

// SetSpendLimitBeforeCounter returns a count of SpendLimitSettingsMock.SetSpendLimit invocations
func (mmSetSpendLimit *SpendLimitSettingsMock) SetSpendLimitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetSpendLimit.beforeSetSpendLimitCounter)
}

// Calls returns a list of arguments used in each call to SpendLimitSettingsMock.SetSpendLimit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetSpendLimit *mSpendLimitSettingsMockSetSpendLimit) Calls() []*SpendLimitSettingsMockSetSpendLimitParams {
	mmSetSpendLimit.mutex.RLock()

	argCopy := make([]*SpendLimitSettingsMockSetSpendLimitParams, len(mmSetSpendLimit.callArgs))
	copy(argCopy, mmSetSpendLimit.callArgs)

	mmSetSpendLimit.mutex.RUnlock()

	return argCopy
}

// MinimockSetSpendLimitDone returns true if the count of the SetSpendLimit invocations corresponds
// the number of defined expectations
func (m *SpendLimitSettingsMock) MinimockSetSpendLimitDone() bool {
	for _, e := range m.SetSpendLimitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetSpendLimitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetSpendLimitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetSpendLimit != nil && mm_atomic.LoadUint64(&m.afterSetSpendLimitCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetSpendLimitInspect logs each unmet expectation
func (m *SpendLimitSettingsMock) MinimockSetSpendLimitInspect() {
	for _, e := range m.SetSpendLimitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpendLimitSettingsMock.SetSpendLimit with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetSpendLimitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetSpendLimitCounter) < 1 {
		if m.SetSpendLimitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpendLimitSettingsMock.SetSpendLimit")
		} else {
			m.t.Errorf("Expected call to SpendLimitSettingsMock.SetSpendLimit with params: %#v", *m.SetSpendLimitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetSpendLimit != nil && mm_atomic.LoadUint64(&m.afterSetSpendLimitCounter) < 1 {
		m.t.Error("Expected call to SpendLimitSettingsMock.SetSpendLimit")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SpendLimitSettingsMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetSpendLimitInspect()

		m.MinimockSetSpendLimitInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SpendLimitSettingsMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SpendLimitSettingsMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetSpendLimitDone() &&
		m.MinimockSetSpendLimitDone()
}
