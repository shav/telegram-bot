package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/shav/telegram-bot/internal/modules/finances/domain/use_cases.spendingStorage -o ./mocks\spending_storage.go -n SpendingStorageMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/shopspring/decimal"
	"github.com/shav/telegram-bot/internal/common/date"
	tr "github.com/shav/telegram-bot/internal/common/transactions"
	finance_models "github.com/shav/telegram-bot/internal/modules/finances/domain/models"
)

// SpendingStorageMock implements finances.spendingStorage
type SpendingStorageMock struct {
	t minimock.Tester

	funcAddSpending          func(ctx context.Context, ts tr.Transaction, userId int64, spending finance_models.Spending) (err error)
	inspectFuncAddSpending   func(ctx context.Context, ts tr.Transaction, userId int64, spending finance_models.Spending)
	afterAddSpendingCounter  uint64
	beforeAddSpendingCounter uint64
	AddSpendingMock          mSpendingStorageMockAddSpending

	funcGetSpendingsAmount          func(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval) (d1 decimal.Decimal, err error)
	inspectFuncGetSpendingsAmount   func(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval)
	afterGetSpendingsAmountCounter  uint64
	beforeGetSpendingsAmountCounter uint64
	GetSpendingsAmountMock          mSpendingStorageMockGetSpendingsAmount

	funcGetSpendingsByCategories          func(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval) (s1 finance_models.SpendingsByCategoryTable, err error)
	inspectFuncGetSpendingsByCategories   func(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval)
	afterGetSpendingsByCategoriesCounter  uint64
	beforeGetSpendingsByCategoriesCounter uint64
	GetSpendingsByCategoriesMock          mSpendingStorageMockGetSpendingsByCategories
}

// NewSpendingStorageMock returns a mock for finances.spendingStorage
func NewSpendingStorageMock(t minimock.Tester) *SpendingStorageMock {
	m := &SpendingStorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddSpendingMock = mSpendingStorageMockAddSpending{mock: m}
	m.AddSpendingMock.callArgs = []*SpendingStorageMockAddSpendingParams{}

	m.GetSpendingsAmountMock = mSpendingStorageMockGetSpendingsAmount{mock: m}
	m.GetSpendingsAmountMock.callArgs = []*SpendingStorageMockGetSpendingsAmountParams{}

	m.GetSpendingsByCategoriesMock = mSpendingStorageMockGetSpendingsByCategories{mock: m}
	m.GetSpendingsByCategoriesMock.callArgs = []*SpendingStorageMockGetSpendingsByCategoriesParams{}

	return m
}

type mSpendingStorageMockAddSpending struct {
	mock               *SpendingStorageMock
	defaultExpectation *SpendingStorageMockAddSpendingExpectation
	expectations       []*SpendingStorageMockAddSpendingExpectation

	callArgs []*SpendingStorageMockAddSpendingParams
	mutex    sync.RWMutex
}

// SpendingStorageMockAddSpendingExpectation specifies expectation struct of the spendingStorage.AddSpending
type SpendingStorageMockAddSpendingExpectation struct {
	mock    *SpendingStorageMock
	params  *SpendingStorageMockAddSpendingParams
	results *SpendingStorageMockAddSpendingResults
	Counter uint64
}

// SpendingStorageMockAddSpendingParams contains parameters of the spendingStorage.AddSpending
type SpendingStorageMockAddSpendingParams struct {
	ctx      context.Context
	ts       tr.Transaction
	userId   int64
	spending finance_models.Spending
}

// SpendingStorageMockAddSpendingResults contains results of the spendingStorage.AddSpending
type SpendingStorageMockAddSpendingResults struct {
	err error
}

// Expect sets up expected params for spendingStorage.AddSpending
func (mmAddSpending *mSpendingStorageMockAddSpending) Expect(ctx context.Context, ts tr.Transaction, userId int64, spending finance_models.Spending) *mSpendingStorageMockAddSpending {
	if mmAddSpending.mock.funcAddSpending != nil {
		mmAddSpending.mock.t.Fatalf("SpendingStorageMock.AddSpending mock is already set by Set")
	}

	if mmAddSpending.defaultExpectation == nil {
		mmAddSpending.defaultExpectation = &SpendingStorageMockAddSpendingExpectation{}
	}

	mmAddSpending.defaultExpectation.params = &SpendingStorageMockAddSpendingParams{ctx, ts, userId, spending}
	for _, e := range mmAddSpending.expectations {
		if minimock.Equal(e.params, mmAddSpending.defaultExpectation.params) {
			mmAddSpending.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddSpending.defaultExpectation.params)
		}
	}

	return mmAddSpending
}

// Inspect accepts an inspector function that has same arguments as the spendingStorage.AddSpending
func (mmAddSpending *mSpendingStorageMockAddSpending) Inspect(f func(ctx context.Context, ts tr.Transaction, userId int64, spending finance_models.Spending)) *mSpendingStorageMockAddSpending {
	if mmAddSpending.mock.inspectFuncAddSpending != nil {
		mmAddSpending.mock.t.Fatalf("Inspect function is already set for SpendingStorageMock.AddSpending")
	}

	mmAddSpending.mock.inspectFuncAddSpending = f

	return mmAddSpending
}

// Return sets up results that will be returned by spendingStorage.AddSpending
func (mmAddSpending *mSpendingStorageMockAddSpending) Return(err error) *SpendingStorageMock {
	if mmAddSpending.mock.funcAddSpending != nil {
		mmAddSpending.mock.t.Fatalf("SpendingStorageMock.AddSpending mock is already set by Set")
	}

	if mmAddSpending.defaultExpectation == nil {
		mmAddSpending.defaultExpectation = &SpendingStorageMockAddSpendingExpectation{mock: mmAddSpending.mock}
	}
	mmAddSpending.defaultExpectation.results = &SpendingStorageMockAddSpendingResults{err}
	return mmAddSpending.mock
}

//Set uses given function f to mock the spendingStorage.AddSpending method
func (mmAddSpending *mSpendingStorageMockAddSpending) Set(f func(ctx context.Context, ts tr.Transaction, userId int64, spending finance_models.Spending) (err error)) *SpendingStorageMock {
	if mmAddSpending.defaultExpectation != nil {
		mmAddSpending.mock.t.Fatalf("Default expectation is already set for the spendingStorage.AddSpending method")
	}

	if len(mmAddSpending.expectations) > 0 {
		mmAddSpending.mock.t.Fatalf("Some expectations are already set for the spendingStorage.AddSpending method")
	}

	mmAddSpending.mock.funcAddSpending = f
	return mmAddSpending.mock
}

// When sets expectation for the spendingStorage.AddSpending which will trigger the result defined by the following
// Then helper
func (mmAddSpending *mSpendingStorageMockAddSpending) When(ctx context.Context, ts tr.Transaction, userId int64, spending finance_models.Spending) *SpendingStorageMockAddSpendingExpectation {
	if mmAddSpending.mock.funcAddSpending != nil {
		mmAddSpending.mock.t.Fatalf("SpendingStorageMock.AddSpending mock is already set by Set")
	}

	expectation := &SpendingStorageMockAddSpendingExpectation{
		mock:   mmAddSpending.mock,
		params: &SpendingStorageMockAddSpendingParams{ctx, ts, userId, spending},
	}
	mmAddSpending.expectations = append(mmAddSpending.expectations, expectation)
	return expectation
}

// Then sets up spendingStorage.AddSpending return parameters for the expectation previously defined by the When method
func (e *SpendingStorageMockAddSpendingExpectation) Then(err error) *SpendingStorageMock {
	e.results = &SpendingStorageMockAddSpendingResults{err}
	return e.mock
}

// AddSpending implements finances.spendingStorage
func (mmAddSpending *SpendingStorageMock) AddSpending(ctx context.Context, ts tr.Transaction, userId int64, spending finance_models.Spending) (err error) {
	mm_atomic.AddUint64(&mmAddSpending.beforeAddSpendingCounter, 1)
	defer mm_atomic.AddUint64(&mmAddSpending.afterAddSpendingCounter, 1)

	if mmAddSpending.inspectFuncAddSpending != nil {
		mmAddSpending.inspectFuncAddSpending(ctx, ts, userId, spending)
	}

	mm_params := &SpendingStorageMockAddSpendingParams{ctx, ts, userId, spending}

	// Record call args
	mmAddSpending.AddSpendingMock.mutex.Lock()
	mmAddSpending.AddSpendingMock.callArgs = append(mmAddSpending.AddSpendingMock.callArgs, mm_params)
	mmAddSpending.AddSpendingMock.mutex.Unlock()

	for _, e := range mmAddSpending.AddSpendingMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddSpending.AddSpendingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddSpending.AddSpendingMock.defaultExpectation.Counter, 1)
		mm_want := mmAddSpending.AddSpendingMock.defaultExpectation.params
		mm_got := SpendingStorageMockAddSpendingParams{ctx, ts, userId, spending}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddSpending.t.Errorf("SpendingStorageMock.AddSpending got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddSpending.AddSpendingMock.defaultExpectation.results
		if mm_results == nil {
			mmAddSpending.t.Fatal("No results are set for the SpendingStorageMock.AddSpending")
		}
		return (*mm_results).err
	}
	if mmAddSpending.funcAddSpending != nil {
		return mmAddSpending.funcAddSpending(ctx, ts, userId, spending)
	}
	mmAddSpending.t.Fatalf("Unexpected call to SpendingStorageMock.AddSpending. %v %v %v %v", ctx, ts, userId, spending)
	return
}

// AddSpendingAfterCounter returns a count of finished SpendingStorageMock.AddSpending invocations
func (mmAddSpending *SpendingStorageMock) AddSpendingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSpending.afterAddSpendingCounter)
}

// AddSpendingBeforeCounter returns a count of SpendingStorageMock.AddSpending invocations
func (mmAddSpending *SpendingStorageMock) AddSpendingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSpending.beforeAddSpendingCounter)
}

// Calls returns a list of arguments used in each call to SpendingStorageMock.AddSpending.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddSpending *mSpendingStorageMockAddSpending) Calls() []*SpendingStorageMockAddSpendingParams {
	mmAddSpending.mutex.RLock()

	argCopy := make([]*SpendingStorageMockAddSpendingParams, len(mmAddSpending.callArgs))
	copy(argCopy, mmAddSpending.callArgs)

	mmAddSpending.mutex.RUnlock()

	return argCopy
}

// MinimockAddSpendingDone returns true if the count of the AddSpending invocations corresponds
// the number of defined expectations
func (m *SpendingStorageMock) MinimockAddSpendingDone() bool {
	for _, e := range m.AddSpendingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddSpendingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddSpendingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSpending != nil && mm_atomic.LoadUint64(&m.afterAddSpendingCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddSpendingInspect logs each unmet expectation
func (m *SpendingStorageMock) MinimockAddSpendingInspect() {
	for _, e := range m.AddSpendingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpendingStorageMock.AddSpending with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddSpendingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddSpendingCounter) < 1 {
		if m.AddSpendingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpendingStorageMock.AddSpending")
		} else {
			m.t.Errorf("Expected call to SpendingStorageMock.AddSpending with params: %#v", *m.AddSpendingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSpending != nil && mm_atomic.LoadUint64(&m.afterAddSpendingCounter) < 1 {
		m.t.Error("Expected call to SpendingStorageMock.AddSpending")
	}
}

type mSpendingStorageMockGetSpendingsAmount struct {
	mock               *SpendingStorageMock
	defaultExpectation *SpendingStorageMockGetSpendingsAmountExpectation
	expectations       []*SpendingStorageMockGetSpendingsAmountExpectation

	callArgs []*SpendingStorageMockGetSpendingsAmountParams
	mutex    sync.RWMutex
}

// SpendingStorageMockGetSpendingsAmountExpectation specifies expectation struct of the spendingStorage.GetSpendingsAmount
type SpendingStorageMockGetSpendingsAmountExpectation struct {
	mock    *SpendingStorageMock
	params  *SpendingStorageMockGetSpendingsAmountParams
	results *SpendingStorageMockGetSpendingsAmountResults
	Counter uint64
}

// SpendingStorageMockGetSpendingsAmountParams contains parameters of the spendingStorage.GetSpendingsAmount
type SpendingStorageMockGetSpendingsAmountParams struct {
	ctx      context.Context
	ts       tr.Transaction
	userId   int64
	interval date.Interval
}

// SpendingStorageMockGetSpendingsAmountResults contains results of the spendingStorage.GetSpendingsAmount
type SpendingStorageMockGetSpendingsAmountResults struct {
	d1  decimal.Decimal
	err error
}

// Expect sets up expected params for spendingStorage.GetSpendingsAmount
func (mmGetSpendingsAmount *mSpendingStorageMockGetSpendingsAmount) Expect(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval) *mSpendingStorageMockGetSpendingsAmount {
	if mmGetSpendingsAmount.mock.funcGetSpendingsAmount != nil {
		mmGetSpendingsAmount.mock.t.Fatalf("SpendingStorageMock.GetSpendingsAmount mock is already set by Set")
	}

	if mmGetSpendingsAmount.defaultExpectation == nil {
		mmGetSpendingsAmount.defaultExpectation = &SpendingStorageMockGetSpendingsAmountExpectation{}
	}

	mmGetSpendingsAmount.defaultExpectation.params = &SpendingStorageMockGetSpendingsAmountParams{ctx, ts, userId, interval}
	for _, e := range mmGetSpendingsAmount.expectations {
		if minimock.Equal(e.params, mmGetSpendingsAmount.defaultExpectation.params) {
			mmGetSpendingsAmount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSpendingsAmount.defaultExpectation.params)
		}
	}

	return mmGetSpendingsAmount
}

// Inspect accepts an inspector function that has same arguments as the spendingStorage.GetSpendingsAmount
func (mmGetSpendingsAmount *mSpendingStorageMockGetSpendingsAmount) Inspect(f func(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval)) *mSpendingStorageMockGetSpendingsAmount {
	if mmGetSpendingsAmount.mock.inspectFuncGetSpendingsAmount != nil {
		mmGetSpendingsAmount.mock.t.Fatalf("Inspect function is already set for SpendingStorageMock.GetSpendingsAmount")
	}

	mmGetSpendingsAmount.mock.inspectFuncGetSpendingsAmount = f

	return mmGetSpendingsAmount
}

// Return sets up results that will be returned by spendingStorage.GetSpendingsAmount
func (mmGetSpendingsAmount *mSpendingStorageMockGetSpendingsAmount) Return(d1 decimal.Decimal, err error) *SpendingStorageMock {
	if mmGetSpendingsAmount.mock.funcGetSpendingsAmount != nil {
		mmGetSpendingsAmount.mock.t.Fatalf("SpendingStorageMock.GetSpendingsAmount mock is already set by Set")
	}

	if mmGetSpendingsAmount.defaultExpectation == nil {
		mmGetSpendingsAmount.defaultExpectation = &SpendingStorageMockGetSpendingsAmountExpectation{mock: mmGetSpendingsAmount.mock}
	}
	mmGetSpendingsAmount.defaultExpectation.results = &SpendingStorageMockGetSpendingsAmountResults{d1, err}
	return mmGetSpendingsAmount.mock
}

//Set uses given function f to mock the spendingStorage.GetSpendingsAmount method
func (mmGetSpendingsAmount *mSpendingStorageMockGetSpendingsAmount) Set(f func(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval) (d1 decimal.Decimal, err error)) *SpendingStorageMock {
	if mmGetSpendingsAmount.defaultExpectation != nil {
		mmGetSpendingsAmount.mock.t.Fatalf("Default expectation is already set for the spendingStorage.GetSpendingsAmount method")
	}

	if len(mmGetSpendingsAmount.expectations) > 0 {
		mmGetSpendingsAmount.mock.t.Fatalf("Some expectations are already set for the spendingStorage.GetSpendingsAmount method")
	}

	mmGetSpendingsAmount.mock.funcGetSpendingsAmount = f
	return mmGetSpendingsAmount.mock
}

// When sets expectation for the spendingStorage.GetSpendingsAmount which will trigger the result defined by the following
// Then helper
func (mmGetSpendingsAmount *mSpendingStorageMockGetSpendingsAmount) When(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval) *SpendingStorageMockGetSpendingsAmountExpectation {
	if mmGetSpendingsAmount.mock.funcGetSpendingsAmount != nil {
		mmGetSpendingsAmount.mock.t.Fatalf("SpendingStorageMock.GetSpendingsAmount mock is already set by Set")
	}

	expectation := &SpendingStorageMockGetSpendingsAmountExpectation{
		mock:   mmGetSpendingsAmount.mock,
		params: &SpendingStorageMockGetSpendingsAmountParams{ctx, ts, userId, interval},
	}
	mmGetSpendingsAmount.expectations = append(mmGetSpendingsAmount.expectations, expectation)
	return expectation
}

// Then sets up spendingStorage.GetSpendingsAmount return parameters for the expectation previously defined by the When method
func (e *SpendingStorageMockGetSpendingsAmountExpectation) Then(d1 decimal.Decimal, err error) *SpendingStorageMock {
	e.results = &SpendingStorageMockGetSpendingsAmountResults{d1, err}
	return e.mock
}

// GetSpendingsAmount implements finances.spendingStorage
func (mmGetSpendingsAmount *SpendingStorageMock) GetSpendingsAmount(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval) (d1 decimal.Decimal, err error) {
	mm_atomic.AddUint64(&mmGetSpendingsAmount.beforeGetSpendingsAmountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSpendingsAmount.afterGetSpendingsAmountCounter, 1)

	if mmGetSpendingsAmount.inspectFuncGetSpendingsAmount != nil {
		mmGetSpendingsAmount.inspectFuncGetSpendingsAmount(ctx, ts, userId, interval)
	}

	mm_params := &SpendingStorageMockGetSpendingsAmountParams{ctx, ts, userId, interval}

	// Record call args
	mmGetSpendingsAmount.GetSpendingsAmountMock.mutex.Lock()
	mmGetSpendingsAmount.GetSpendingsAmountMock.callArgs = append(mmGetSpendingsAmount.GetSpendingsAmountMock.callArgs, mm_params)
	mmGetSpendingsAmount.GetSpendingsAmountMock.mutex.Unlock()

	for _, e := range mmGetSpendingsAmount.GetSpendingsAmountMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.err
		}
	}

	if mmGetSpendingsAmount.GetSpendingsAmountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSpendingsAmount.GetSpendingsAmountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSpendingsAmount.GetSpendingsAmountMock.defaultExpectation.params
		mm_got := SpendingStorageMockGetSpendingsAmountParams{ctx, ts, userId, interval}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSpendingsAmount.t.Errorf("SpendingStorageMock.GetSpendingsAmount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSpendingsAmount.GetSpendingsAmountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSpendingsAmount.t.Fatal("No results are set for the SpendingStorageMock.GetSpendingsAmount")
		}
		return (*mm_results).d1, (*mm_results).err
	}
	if mmGetSpendingsAmount.funcGetSpendingsAmount != nil {
		return mmGetSpendingsAmount.funcGetSpendingsAmount(ctx, ts, userId, interval)
	}
	mmGetSpendingsAmount.t.Fatalf("Unexpected call to SpendingStorageMock.GetSpendingsAmount. %v %v %v %v", ctx, ts, userId, interval)
	return
}

// GetSpendingsAmountAfterCounter returns a count of finished SpendingStorageMock.GetSpendingsAmount invocations
func (mmGetSpendingsAmount *SpendingStorageMock) GetSpendingsAmountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSpendingsAmount.afterGetSpendingsAmountCounter)
}

// GetSpendingsAmountBeforeCounter returns a count of SpendingStorageMock.GetSpendingsAmount invocations
func (mmGetSpendingsAmount *SpendingStorageMock) GetSpendingsAmountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSpendingsAmount.beforeGetSpendingsAmountCounter)
}

// Calls returns a list of arguments used in each call to SpendingStorageMock.GetSpendingsAmount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSpendingsAmount *mSpendingStorageMockGetSpendingsAmount) Calls() []*SpendingStorageMockGetSpendingsAmountParams {
	mmGetSpendingsAmount.mutex.RLock()

	argCopy := make([]*SpendingStorageMockGetSpendingsAmountParams, len(mmGetSpendingsAmount.callArgs))
	copy(argCopy, mmGetSpendingsAmount.callArgs)

	mmGetSpendingsAmount.mutex.RUnlock()

	return argCopy
}

// MinimockGetSpendingsAmountDone returns true if the count of the GetSpendingsAmount invocations corresponds
// the number of defined expectations
func (m *SpendingStorageMock) MinimockGetSpendingsAmountDone() bool {
	for _, e := range m.GetSpendingsAmountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSpendingsAmountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSpendingsAmountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSpendingsAmount != nil && mm_atomic.LoadUint64(&m.afterGetSpendingsAmountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSpendingsAmountInspect logs each unmet expectation
func (m *SpendingStorageMock) MinimockGetSpendingsAmountInspect() {
	for _, e := range m.GetSpendingsAmountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpendingStorageMock.GetSpendingsAmount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSpendingsAmountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSpendingsAmountCounter) < 1 {
		if m.GetSpendingsAmountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpendingStorageMock.GetSpendingsAmount")
		} else {
			m.t.Errorf("Expected call to SpendingStorageMock.GetSpendingsAmount with params: %#v", *m.GetSpendingsAmountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSpendingsAmount != nil && mm_atomic.LoadUint64(&m.afterGetSpendingsAmountCounter) < 1 {
		m.t.Error("Expected call to SpendingStorageMock.GetSpendingsAmount")
	}
}

type mSpendingStorageMockGetSpendingsByCategories struct {
	mock               *SpendingStorageMock
	defaultExpectation *SpendingStorageMockGetSpendingsByCategoriesExpectation
	expectations       []*SpendingStorageMockGetSpendingsByCategoriesExpectation

	callArgs []*SpendingStorageMockGetSpendingsByCategoriesParams
	mutex    sync.RWMutex
}

// SpendingStorageMockGetSpendingsByCategoriesExpectation specifies expectation struct of the spendingStorage.GetSpendingsByCategories
type SpendingStorageMockGetSpendingsByCategoriesExpectation struct {
	mock    *SpendingStorageMock
	params  *SpendingStorageMockGetSpendingsByCategoriesParams
	results *SpendingStorageMockGetSpendingsByCategoriesResults
	Counter uint64
}

// SpendingStorageMockGetSpendingsByCategoriesParams contains parameters of the spendingStorage.GetSpendingsByCategories
type SpendingStorageMockGetSpendingsByCategoriesParams struct {
	ctx      context.Context
	ts       tr.Transaction
	userId   int64
	interval date.Interval
}

// SpendingStorageMockGetSpendingsByCategoriesResults contains results of the spendingStorage.GetSpendingsByCategories
type SpendingStorageMockGetSpendingsByCategoriesResults struct {
	s1  finance_models.SpendingsByCategoryTable
	err error
}

// Expect sets up expected params for spendingStorage.GetSpendingsByCategories
func (mmGetSpendingsByCategories *mSpendingStorageMockGetSpendingsByCategories) Expect(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval) *mSpendingStorageMockGetSpendingsByCategories {
	if mmGetSpendingsByCategories.mock.funcGetSpendingsByCategories != nil {
		mmGetSpendingsByCategories.mock.t.Fatalf("SpendingStorageMock.GetSpendingsByCategories mock is already set by Set")
	}

	if mmGetSpendingsByCategories.defaultExpectation == nil {
		mmGetSpendingsByCategories.defaultExpectation = &SpendingStorageMockGetSpendingsByCategoriesExpectation{}
	}

	mmGetSpendingsByCategories.defaultExpectation.params = &SpendingStorageMockGetSpendingsByCategoriesParams{ctx, ts, userId, interval}
	for _, e := range mmGetSpendingsByCategories.expectations {
		if minimock.Equal(e.params, mmGetSpendingsByCategories.defaultExpectation.params) {
			mmGetSpendingsByCategories.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSpendingsByCategories.defaultExpectation.params)
		}
	}

	return mmGetSpendingsByCategories
}

// Inspect accepts an inspector function that has same arguments as the spendingStorage.GetSpendingsByCategories
func (mmGetSpendingsByCategories *mSpendingStorageMockGetSpendingsByCategories) Inspect(f func(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval)) *mSpendingStorageMockGetSpendingsByCategories {
	if mmGetSpendingsByCategories.mock.inspectFuncGetSpendingsByCategories != nil {
		mmGetSpendingsByCategories.mock.t.Fatalf("Inspect function is already set for SpendingStorageMock.GetSpendingsByCategories")
	}

	mmGetSpendingsByCategories.mock.inspectFuncGetSpendingsByCategories = f

	return mmGetSpendingsByCategories
}

// Return sets up results that will be returned by spendingStorage.GetSpendingsByCategories
func (mmGetSpendingsByCategories *mSpendingStorageMockGetSpendingsByCategories) Return(s1 finance_models.SpendingsByCategoryTable, err error) *SpendingStorageMock {
	if mmGetSpendingsByCategories.mock.funcGetSpendingsByCategories != nil {
		mmGetSpendingsByCategories.mock.t.Fatalf("SpendingStorageMock.GetSpendingsByCategories mock is already set by Set")
	}

	if mmGetSpendingsByCategories.defaultExpectation == nil {
		mmGetSpendingsByCategories.defaultExpectation = &SpendingStorageMockGetSpendingsByCategoriesExpectation{mock: mmGetSpendingsByCategories.mock}
	}
	mmGetSpendingsByCategories.defaultExpectation.results = &SpendingStorageMockGetSpendingsByCategoriesResults{s1, err}
	return mmGetSpendingsByCategories.mock
}

//Set uses given function f to mock the spendingStorage.GetSpendingsByCategories method
func (mmGetSpendingsByCategories *mSpendingStorageMockGetSpendingsByCategories) Set(f func(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval) (s1 finance_models.SpendingsByCategoryTable, err error)) *SpendingStorageMock {
	if mmGetSpendingsByCategories.defaultExpectation != nil {
		mmGetSpendingsByCategories.mock.t.Fatalf("Default expectation is already set for the spendingStorage.GetSpendingsByCategories method")
	}

	if len(mmGetSpendingsByCategories.expectations) > 0 {
		mmGetSpendingsByCategories.mock.t.Fatalf("Some expectations are already set for the spendingStorage.GetSpendingsByCategories method")
	}

	mmGetSpendingsByCategories.mock.funcGetSpendingsByCategories = f
	return mmGetSpendingsByCategories.mock
}

// When sets expectation for the spendingStorage.GetSpendingsByCategories which will trigger the result defined by the following
// Then helper
func (mmGetSpendingsByCategories *mSpendingStorageMockGetSpendingsByCategories) When(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval) *SpendingStorageMockGetSpendingsByCategoriesExpectation {
	if mmGetSpendingsByCategories.mock.funcGetSpendingsByCategories != nil {
		mmGetSpendingsByCategories.mock.t.Fatalf("SpendingStorageMock.GetSpendingsByCategories mock is already set by Set")
	}

	expectation := &SpendingStorageMockGetSpendingsByCategoriesExpectation{
		mock:   mmGetSpendingsByCategories.mock,
		params: &SpendingStorageMockGetSpendingsByCategoriesParams{ctx, ts, userId, interval},
	}
	mmGetSpendingsByCategories.expectations = append(mmGetSpendingsByCategories.expectations, expectation)
	return expectation
}

// Then sets up spendingStorage.GetSpendingsByCategories return parameters for the expectation previously defined by the When method
func (e *SpendingStorageMockGetSpendingsByCategoriesExpectation) Then(s1 finance_models.SpendingsByCategoryTable, err error) *SpendingStorageMock {
	e.results = &SpendingStorageMockGetSpendingsByCategoriesResults{s1, err}
	return e.mock
}

// GetSpendingsByCategories implements finances.spendingStorage
func (mmGetSpendingsByCategories *SpendingStorageMock) GetSpendingsByCategories(ctx context.Context, ts tr.Transaction, userId int64, interval date.Interval) (s1 finance_models.SpendingsByCategoryTable, err error) {
	mm_atomic.AddUint64(&mmGetSpendingsByCategories.beforeGetSpendingsByCategoriesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSpendingsByCategories.afterGetSpendingsByCategoriesCounter, 1)

	if mmGetSpendingsByCategories.inspectFuncGetSpendingsByCategories != nil {
		mmGetSpendingsByCategories.inspectFuncGetSpendingsByCategories(ctx, ts, userId, interval)
	}

	mm_params := &SpendingStorageMockGetSpendingsByCategoriesParams{ctx, ts, userId, interval}

	// Record call args
	mmGetSpendingsByCategories.GetSpendingsByCategoriesMock.mutex.Lock()
	mmGetSpendingsByCategories.GetSpendingsByCategoriesMock.callArgs = append(mmGetSpendingsByCategories.GetSpendingsByCategoriesMock.callArgs, mm_params)
	mmGetSpendingsByCategories.GetSpendingsByCategoriesMock.mutex.Unlock()

	for _, e := range mmGetSpendingsByCategories.GetSpendingsByCategoriesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetSpendingsByCategories.GetSpendingsByCategoriesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSpendingsByCategories.GetSpendingsByCategoriesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSpendingsByCategories.GetSpendingsByCategoriesMock.defaultExpectation.params
		mm_got := SpendingStorageMockGetSpendingsByCategoriesParams{ctx, ts, userId, interval}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSpendingsByCategories.t.Errorf("SpendingStorageMock.GetSpendingsByCategories got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSpendingsByCategories.GetSpendingsByCategoriesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSpendingsByCategories.t.Fatal("No results are set for the SpendingStorageMock.GetSpendingsByCategories")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetSpendingsByCategories.funcGetSpendingsByCategories != nil {
		return mmGetSpendingsByCategories.funcGetSpendingsByCategories(ctx, ts, userId, interval)
	}
	mmGetSpendingsByCategories.t.Fatalf("Unexpected call to SpendingStorageMock.GetSpendingsByCategories. %v %v %v %v", ctx, ts, userId, interval)
	return
}

// GetSpendingsByCategoriesAfterCounter returns a count of finished SpendingStorageMock.GetSpendingsByCategories invocations
func (mmGetSpendingsByCategories *SpendingStorageMock) GetSpendingsByCategoriesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSpendingsByCategories.afterGetSpendingsByCategoriesCounter)
}

// GetSpendingsByCategoriesBeforeCounter returns a count of SpendingStorageMock.GetSpendingsByCategories invocations
func (mmGetSpendingsByCategories *SpendingStorageMock) GetSpendingsByCategoriesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSpendingsByCategories.beforeGetSpendingsByCategoriesCounter)
}

// Calls returns a list of arguments used in each call to SpendingStorageMock.GetSpendingsByCategories.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSpendingsByCategories *mSpendingStorageMockGetSpendingsByCategories) Calls() []*SpendingStorageMockGetSpendingsByCategoriesParams {
	mmGetSpendingsByCategories.mutex.RLock()

	argCopy := make([]*SpendingStorageMockGetSpendingsByCategoriesParams, len(mmGetSpendingsByCategories.callArgs))
	copy(argCopy, mmGetSpendingsByCategories.callArgs)

	mmGetSpendingsByCategories.mutex.RUnlock()

	return argCopy
}

// MinimockGetSpendingsByCategoriesDone returns true if the count of the GetSpendingsByCategories invocations corresponds
// the number of defined expectations
func (m *SpendingStorageMock) MinimockGetSpendingsByCategoriesDone() bool {
	for _, e := range m.GetSpendingsByCategoriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSpendingsByCategoriesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSpendingsByCategoriesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSpendingsByCategories != nil && mm_atomic.LoadUint64(&m.afterGetSpendingsByCategoriesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSpendingsByCategoriesInspect logs each unmet expectation
func (m *SpendingStorageMock) MinimockGetSpendingsByCategoriesInspect() {
	for _, e := range m.GetSpendingsByCategoriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpendingStorageMock.GetSpendingsByCategories with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSpendingsByCategoriesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSpendingsByCategoriesCounter) < 1 {
		if m.GetSpendingsByCategoriesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpendingStorageMock.GetSpendingsByCategories")
		} else {
			m.t.Errorf("Expected call to SpendingStorageMock.GetSpendingsByCategories with params: %#v", *m.GetSpendingsByCategoriesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSpendingsByCategories != nil && mm_atomic.LoadUint64(&m.afterGetSpendingsByCategoriesCounter) < 1 {
		m.t.Error("Expected call to SpendingStorageMock.GetSpendingsByCategories")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SpendingStorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddSpendingInspect()

		m.MinimockGetSpendingsAmountInspect()

		m.MinimockGetSpendingsByCategoriesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SpendingStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SpendingStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddSpendingDone() &&
		m.MinimockGetSpendingsAmountDone() &&
		m.MinimockGetSpendingsByCategoriesDone()
}
